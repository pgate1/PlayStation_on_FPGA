/*
	DMA for GPU
		by pgate1
*/

circuit DMA_GPU
{
	input DmaMADR_2<32>, DmaBCR_2<32>;

	output A<21>;
	instrout wram_read(A);
	input Din<32>;

	output Dout<32>;
	instrout gpu_dma_write_req(Dout);
	instrout gpu_dma_read_req();
	instrout wram_write(A, Dout);

	reg block_count<16>, block_size<16>;
	reg dma_block<16>, dma_count<16>;

	reg madr<21>, dma_data<32>;

	instrin Execute_mem2vram;
	instrin wram_ack;
	output running;

	instrin Execute_chain;
	reg block_addr<21>, next_addr<24>;

	instrin Execute_vram2mem;

	input gpu_busy, gpu_drawing;
	instrin gpu_vram_ack;

	output gpu_status_ready_recieve_dmablock;

	instrin run33;
	reg trans_count<16>;
	reg_wr count_rst;
	instrout interrupt;
	output int_waiting;

instrself halt(h_code);
sel h_code<8>;
reg_wr halt_code_reg<8>;
output halt_code<8>;
output dbg<32>;
reg_wr dbg_reg<32>;

	stage_name run_mem2vram { task do(); }
	stage_name run_chain { task do(); }
	stage_name run_vram2mem { task do(); }
	stage_name int_wait { task do(count_rst); }

	instruct halt halt_code_reg := h_code;
	halt_code = halt_code_reg;
//dbg = 0x000000 || count_m;
//dbg = sum;
dbg = dbg_reg;

	instruct Execute_mem2vram par{
		generate run_mem2vram.do();
	}

	instruct Execute_chain par{
		generate run_chain.do();
	}

	instruct Execute_vram2mem par{
		generate run_vram2mem.do();
	}

	running =
	//	Execute_mem2vram | Execute_chain | Execute_vram2mem |
		run_mem2vram.do | run_chain.do | run_vram2mem.do;

//	running =
//		run_mem2vram.do | run_vram2mem.do |
//		(run_chain.do & ^gpu_drawing);

	gpu_status_ready_recieve_dmablock = ^(run_mem2vram.do | run_chain.do);

	int_waiting = int_wait.do;

	stage run_mem2vram {
		first_state st_init;
		state st_init if(^gpu_busy){
			if(run_chain.do){
				madr := block_addr;
				goto st_read;
			}
			else{
				// u32 *ptr = (u32*)(ram + (madr>>2));
				madr := DmaMADR_2<20:0>;
				// u32 bcr = DmaBCR[n];
				// u32 size = (bcr >> 16) * (bcr & 0xFFFF);
				block_count := DmaBCR_2<31:16>;
				block_size := DmaBCR_2<15:0>;
				trans_count := 0;
				if((DmaBCR_2<31:16>==0) | (DmaBCR_2<15:0>==0)) goto st_end;
				else goto st_read;
			}
			dma_count := 0;
			dma_block := 1;
		}
		state st_read if(wram_ack & ^gpu_busy){
			wram_read(madr);
			madr += 4;
			dma_count++;
			trans_count++;
			goto st_readw;
		}
		state st_readw if(wram_ack & ^gpu_busy){
			dma_data := Din;
			goto st_write;
		}
		state st_write if(^gpu_busy){
			gpu_dma_write_req(dma_data);
			if(dma_count==block_size){
				if(dma_block==block_count) goto st_end;
				else goto st_read;
				dma_count := 0;
				dma_block++;
			}
			else goto st_read;
		}
		state st_end if(^gpu_busy){
			if(^run_chain.do){
				generate int_wait.do(0b1);
			}
			goto st_init;
			finish;
		}
	}

	stage run_chain {
		first_state st_init;
		state st_init if(^gpu_busy){
			next_addr := DmaMADR_2<23:0>;
			trans_count := 0;
			goto st_read;
		}
		state st_read if(wram_ack & ^gpu_busy){
			wram_read(next_addr<20:0>);
			block_addr := next_addr<20:0> + 4;
			goto st_trans;
		}
		state st_trans if(wram_ack & ^gpu_busy){
			block_size := 0x00 || Din<31:24>;
			block_count := 0x0001;
			next_addr := Din<23:0>;
			if(Din<31:24>!=0) generate run_mem2vram.do();
			goto st_end;
		}
		state st_end if(^run_mem2vram.do & ^gpu_busy){
			if((next_addr!=0xFFFFFF) & (next_addr<20:2>!=0)) goto st_read;
			else{
				generate int_wait.do(0b1);
				goto st_init;
				finish;
			}
		}
	}

	stage run_vram2mem {
		first_state st_init;
		state st_init if(^gpu_busy){
			// uint32 *ptr = (uint32*)(ram + (madr>>2));
			madr := DmaMADR_2<20:0>;
			// uint32 bcr = DmaBCR[n];
			block_count := DmaBCR_2<31:16>;
			block_size := DmaBCR_2<15:0>;
			dma_count := 0;
			dma_block := 1;
			trans_count := 0;
			if((DmaBCR_2<31:16>==0) | (DmaBCR_2<15:0>==0)) goto st_end;
			else goto st_read;
		}
		state st_read if(^gpu_busy){
			gpu_dma_read_req();
			dma_count++;
			trans_count++;
			goto st_readw;
		}
		state st_readw if(gpu_vram_ack){
			dma_data := Din;
			goto st_write;
		}
		state st_write if(wram_ack & ^gpu_busy){
			wram_write(madr, dma_data);
			madr += 4;
			if(dma_count==block_size){
				if(dma_block==block_count) goto st_end;
				else goto st_read;
				dma_count := 0;
				dma_block++;
			}
			else goto st_read;
		}
		state st_end if(wram_ack & ^gpu_busy){
			generate int_wait.do(0b1);
			goto st_init;
			finish;
		}
	}

	stage int_wait {
		reg int_wait_count<16>;
		first_state st1;
		state st1 par{
			int_wait_count := trans_count;
			count_rst := 0b0;
			if(count_rst) goto st2;
		}
		state st2 if(run33){
			int_wait_count--;
			if(int_wait_count==0){
				interrupt();
				goto st1;
				finish;
			}
			if(count_rst) goto st1;
			if(run_mem2vram.do | run_chain.do | run_vram2mem.do){
				goto st1;
				finish;
			}
		}
	}

}
