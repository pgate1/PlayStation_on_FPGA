/*
	Motion Decoder
		by pgate1
*/

circuit MDEC
{
	input DmaMADR_0<32>, DmaBCR_0<32>;
	input DmaMADR_1<32>, DmaBCR_1<32>;

	input din<32>;
	instrin WriteCmd(din), WriteCtrl(din);
	instrin ReadData, ReadStatus;
	output dout<32>;

	output wram_adrs<21>, wram_din<24>, wram_word<2>;
	instrout wram_write(wram_adrs, wram_din, wram_word);
	instrout wram_read(wram_adrs);
	input wram_dout<16>;
	instrin wram_ack;

	reg bcr<32>;
	sel dma_size<16>;

	reg_wr reg0<32>, reg1<32>;

	reg_wr rl<21>;

	instrin DMAin_Execute, DMAout_Execute;
	output running, waiting;

	instrin run33;
	reg int_wait_max<16>;
	reg_wr count0_rst, count1_rst;
	instrout mdec0_interrupt, mdec1_interrupt;

	instrout end_of_data;

	stage_name run_dma0 { task do(); }
	stage_name int_wait0 { task do(int_wait_max, count0_rst); }
	stage_name run_dma1 { task do(); }
	stage_name int_wait1 { task do(int_wait_max, count1_rst); }

	instruct WriteCmd par{
		reg0 := din;
	}

	instruct WriteCtrl par{
		if(din<31>){
			reg0 := 0x00000000;
			reg1 := 0x00000000;
		}
	}

	instruct ReadData par{
		dout = reg0;
	}

	instruct ReadStatus par{
		dout = reg1;
	}

	// uint32 size = (bcr >> 16) * (bcr & 0xFFFF);
	// 16 * 16 = 32;
	dma_size = 64;//size_mul.con(bcr<31:16>, bcr<15:0>).dout;

	running = run_dma0.do | run_dma1.do;
	waiting = running | int_wait0.do | int_wait1.do;

	instruct DMAin_Execute par{
		generate run_dma0.do();
	}

	instruct DMAout_Execute par{
		generate run_dma1.do();
	}

	stage run_dma0 {
		first_state st1;
		state st1 par{
			reg1 |= 0x00800000;
			bcr := DmaBCR_0;
			goto st2;
		}
		state st2 par{
			switch(reg0<31:29>){
				case 0: par{
					mdec0_interrupt();
				}
				case 1: par{
					rl := DmaMADR_0<20:2> || 0b00;
					reg1 |= 0x20000000; // BUSY
				}
				case 2: par{
					generate int_wait0.do(dma_size >> 2, 1);
				}
				case 3: par{
					generate int_wait0.do(dma_size >> 2, 1);
				}
			}

			goto st1;
			finish;
		}
	}

	stage int_wait0 {
		reg int_wait_count0<16>;
		first_state st1;
		state st1 par{
			int_wait_count0 := int_wait_max;
			count0_rst := 0b0;
			if(count0_rst) goto st2;
		}
		state st2 if(run33){
			int_wait_count0--;
			if(int_wait_count0==0){
				mdec0_interrupt();
				goto st1;
				finish;
			}
			if(count0_rst) goto st1;
		}
	}

	stage run_dma1 {
		reg block_count<5>;
		reg col<8>;
		reg image_adrs<21>;
		reg image_count<8>;
		first_state st_init;
		state st_init par{
			bcr := DmaBCR_1;
			block_count := 1;
			image_adrs := DmaMADR_1<20:2> || 0b00;
			goto st_end;
		//	goto st_read;
		}
/*
		state st_read if(wram_ack){
			wram_read(rl);
			rl += 2;
			goto st_readw;
		}
		state st_readw if(wram_ack){
			if(wram_dout!=0xFE00){
				col := wram_dout<13:6>;
				goto st_read;
			}
			else{ // 0xFE00
				image_count := 0;
				goto st_write;
			}
		}
		state st_write if(wram_ack){
			any{
				reg0<27> : par{ // 15bit color
					wram_write(image_adrs, 0x00 || col || col, 2);
					image_adrs += 2;
				}
				else : par{ // 24bit color
					wram_write(image_adrs, col || col || col, 3);
					image_adrs += 3;
				}
			}
			image_count++;
			if(image_count==255){
				if(block_count==12) goto st_end; // test
				else goto st_read;
				block_count++;
			}
		}
*/
		state st_end if(wram_ack){
			generate int_wait1.do(18432 /*dma_size << 2*/, 1);
			goto st_init;
			finish;
		}
	}

	stage int_wait1 {
		reg int_wait_count1<16>;
		first_state st1;
		state st1 par{
			int_wait_count1 := int_wait_max;
			count1_rst := 0b0;
			if(count1_rst) goto st2;
		}
		state st2 if(run33){
			int_wait_count1--;
			if(int_wait_count1==0){
				mdec1_interrupt();

			//	end_of_data();
				reg1 &= ^0x20800000;

				goto st1;
				finish;
			}
			if(count1_rst) goto st1;
		}
	}

}
