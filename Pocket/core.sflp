
/*
	PlayStation on FPGA feat. Pocket
	Copyright 2023 pgate1
*/

%i "../PlayStation_core.h"
%i "../DDS_50to33868800.h"
%i "../VGA_ctrl.h"
%i "../view_ram_ctrl.h"
%i "../../../Pocket/sram_ctrl.h"

%i "../../../hdl/USB-JTAG/DE0-CV/vjtag_uart.h"

circuit core
{
	input key<16>;
//--------------------- SDRAM Interface --------------------
	instrout sdram_write(sdram_adrs, sdram_din, sdram_enable, sdram_burst);
	output sdram_adrs<25>, sdram_din<128>, sdram_enable<16>, sdram_burst<4>;
	instrout sdram_read(sdram_adrs, sdram_burst);
	input sdram_dout<128>, sdram_ack_100; reg sdram_ack;
//--------------------- SRAM -------------------------------
	sram_ctrl sram;
	output SRAM_OEn, SRAM_WEn, SRAM_UBn, SRAM_LBn;
	output SRAM_ADDR<17>, SRAM_Din<16>, SRAM_DEn;
	input SRAM_Dout<16>;
//--------------------- VGA --------------------------------
	VGA_ctrl vga;
	output VGA_HS, VGA_VS, VGA_DE;
	output VGA_R<8>, VGA_G<8>, VGA_B<8>;
//----------------------------------------------------------
	output set_sdram; reg_wr set_sdram_reg;
//	output set_bram; reg_wr set_bram_reg;
	output set_sram; reg_wr set_sram_reg;
	output target_id<16>; reg_wr target_id_reg<16>;
	output target_slotoffset<32>; reg_wr target_slotoffset_reg<32>;
	output target_bridgeaddr<32>; reg_wr target_bridgeaddr_reg<32>;
	output target_length<32>; reg_wr target_length_reg<32>;
//	input bram_word_wr, bram_wdata<32>;
	input sram_word_wr, sram_wdata<32>;
	input target_dataslot_read, ram_reloading;
//----------------------------------------------------------

	reg_ws reset;

	PlayStation_core psx;
	DDS_50to33868800 dds;

	view_ram_ctrl view_ram;

	reg_wr exe_read_ok, psx_run_ok;

	reg_wr f_bios, f_exe;

	vjtag_uart vjtag;

	reg_wr count_1sec<26>, pass_1sec;
	reg fps<8>, fps_count<8>;

	instrself halt(halt_sel);
	sel halt_sel<8>;
	reg_wr halt_code<8>;

reg_wr dbg_reg<32>;

	stage_name apf2sdram { task do(target_id_reg, target_slotoffset_reg, target_bridgeaddr_reg, target_length_reg); }
	stage_name check_file { task do(); }
	stage_name wram_clear { task do(); }
//	stage_name apf2bram { task do(target_id_reg, target_slotoffset_reg, target_length_reg); }
	stage_name apf2sram { task do(target_id_reg, target_slotoffset_reg, target_length_reg); }
	stage_name rom_read { task do(); }
	stage_name exe_read { task do(); }

	if(reset){
		generate apf2sdram.do(0x0020, 0, 0x01000000, 524288); // BIOS
		reset := 0b0;
	}

	instruct halt halt_code := halt_sel;

	SRAM_OEn = sram.OEn;
	SRAM_WEn = sram.WEn;
	SRAM_UBn = sram.UBn;
	SRAM_LBn = sram.LBn;
	SRAM_DEn = sram.DEn;
	SRAM_ADDR = sram.ADDR;
	SRAM_Din = sram.Din;
	sram.Dout = SRAM_Dout;

	reg_wr radrs<3>;
	sel vj_data<32>;
	if(radrs<2>==0b0) vj_data = 0x00 || fps || halt_code || psx.halt_code;
	if(radrs<2>==0b1) vj_data = psx.dbg;
//	vj_data = dbg_reg;
	instruct vjtag.send_init par{
		radrs := 0;
	}
	reg_wr vjtag_send, send_data<8>;
	instruct vjtag.send_ready par{
		switch(radrs<1:0>){
			case 0: send_data := vj_data<7:0>;
			case 1: send_data := vj_data<15:8>;
			case 2: send_data := vj_data<23:16>;
			case 3: send_data := vj_data<31:24>;
		}
		radrs++;
		vjtag_send := 0b1;
	}
	if(vjtag_send){
		vjtag.send(send_data);
		vjtag_send := 0b0;
	}

	sdram_ack := sdram_ack_100;

	set_sdram = set_sdram_reg;
//	set_bram = set_bram_reg;
	set_sram = set_sram_reg;
	target_id = target_id_reg;
	target_slotoffset = target_slotoffset_reg;
	target_bridgeaddr = target_bridgeaddr_reg;
	target_length = target_length_reg;

	reg_wr clock25M_div;
	clock25M_div := ^clock25M_div;
	if(clock25M_div) vga.htiming();
	reg_wr vga_en_reg, vga_hsync_reg, vga_vsync_reg;
	vga_en_reg := vga.en; VGA_DE = vga_en_reg;
	vga_hsync_reg := vga.h_sync; VGA_HS = vga_hsync_reg;
	vga_vsync_reg := vga.v_sync; VGA_VS = vga_vsync_reg;

	if(((vga.h_count==10) | (vga.h_count==630) |
	    (vga.v_count==10) | (vga.v_count==470)) & /|psx.halt_code){
		if(psx.halt_part<7>){ // CPU halt
			vga.iR = 0xFF; vga.iG = 0x00; vga.iB = 0x00;
		}
		else{ // other halt
			vga.iR = 0xFF; vga.iG = 0xFF; vga.iB = 0x00;
		}
	}
	else{
		vga.iR = view_ram.out_R || view_ram.out_R<4:2>;
		vga.iG = view_ram.out_G || view_ram.out_G<4:2>;
		vga.iB = view_ram.out_B || view_ram.out_B<4:2>;
	}
	reg_wr vga_R_reg<8>, vga_G_reg<8>, vga_B_reg<8>;
	vga_R_reg := vga.oR;
	vga_G_reg := vga.oG;
	vga_B_reg := vga.oB;
	VGA_R = vga_R_reg;
	VGA_G = vga_G_reg;
	VGA_B = vga_B_reg;

	if(count_1sec==50000000){
		pass_1sec := 0b1;
		count_1sec := 1;
		fps := fps_count;
		fps_count := 0;
	}
	else count_1sec++;

	instruct psx.view_on par{
		sel psx_view_x<9>, psx_view_y<8>;

		if(psx.dispW /*| psx.sw_view_half*/) psx_view_x = psx.view_x<9:1>; // 640->320
		else psx_view_x = psx.view_x<8:0>; // 320->320
		if(psx.dispH /*| psx.sw_view_half*/) psx_view_y = psx.view_y<8:1>; // 480->240
		else psx_view_y = psx.view_y<7:0>; // 240->240

		view_ram.write(psx_view_x, psx_view_y,
			psx.view_R<7:3>, psx.view_G<7:3>, psx.view_B<7:3>);
	}
	instruct vga.view view_ram.read();

	instruct vga.vblank_begin par{
		view_ram.read_adrs_reset();
		reg_wr vblank_wait;
		if(exe_read_ok & (^vblank_wait) & pass_1sec){
			psx_run_ok := 0b1;
			vblank_wait := 0b1;
		}
		if(/*(^psx.drawing) &*/ (^psx.stop)){
			if(psx_run_ok) psx.vblank_begin();
			if(^psx.sw_kernel_run){
				view_ram.bank_change();
				fps_count++;
			}
		}
	}
	instruct vga.vblank_end psx.vblank_end();
	instruct psx.display_flip if(psx.sw_kernel_run){
		view_ram.bank_change();
		fps_count++;
	}
//	instruct psx.fill_view_on view_ram.fill_view_on(); // 20230402 コメントアウト
//	instruct psx.draw_notdisp_side view_ram.draw_notdisp_side();

	if(exe_read_ok & psx_run_ok & (halt_code==0x00) & (^psx.stop)){
		instruct dds.run psx.run33();
		psx.cpu_run();
	}

	// PS : □,×,○,△,R,L,R2,L2,←,↓,→,↑,St,0,0,Sl
	psx.key_in = (
		key<7> || key<5> || key<4> || key<6> || 
		key<9> || key<8> || key<11> || key<10> || 
		key<2> || key<1> || key<3> || key<0> || 
		key<15> || 0b00 || key<14>);

psx.sw_reverb_off();
psx.sw_spu_off();
psx.sw_spuenv_off();

	any{
		f_bios : psx.sw_cdrom_ctrl = 0b11; // BIOS
		f_exe  : psx.sw_cdrom_ctrl = 0b01; // PS-X EXE
		else   : psx.sw_cdrom_ctrl = 0b00; // Game ROM
	}

	if(^f_exe) psx.sw_kernel_run();
//	if(sw_7) psx.stop();

	reg_wr key_14_push, key_14_hold; // Select
	if(key<14> & ^key_14_push) key_14_push := 0b1;
	if(key_14_push & ^key<14>){ key_14_push := 0b0; key_14_hold := ^key_14_hold; }
	reg_wr key_9_push, key_9_hold; // R
	if(key<9> & ^key_9_push) key_9_push := 0b1;
	if(key_9_push & ^key<9>){ key_9_push := 0b0; key_9_hold := ^key_9_hold; }
//	if(key_14_hold) psx.sw_texture_off();
	if(key_14_hold /*& key_9_hold*/) psx.sw_texcache_off();

/*
SDRAM 64MB 16bit 32Mword<25>
0b00000   || psx.A<20:2> || 0b0      WorkRAM  2MB 32bit 512kWord<19>
0b000010  || psx.vram_adrs<18:0>     VideoRAM 1MB 16bit 512kWord<19>
0b0100000 || psx.A<18:2> || 0b0      BIOS   512kB 32bit 128kWord<17>
*/
	reg_wr psx_Word<5>, psx_A<21>;

	instruct psx.WRAM_READ par{
		any{
			(psx.Word==1) | (psx.Word==2) : par{
				sdram_read(0b00000 || psx.A<20:1>, 1);
			}
			else : par{// byte 16,12,8,4 -> burst 8,6,4,2
				sdram_read(0b00000 || psx.A<20:2> || 0b0, psx.Word<4:1>);
			}
		}
		psx_Word := psx.Word;
		psx_A := psx.A;
	}
	if(sdram_ack) psx.wram_ack();

	any{
		((psx_Word==1) | (psx_Word==2)) & (psx_A<1>==0b1) : par{
			psx.Din = sdram_dout << 16;
		}
		else : par{
			psx.Din = sdram_dout;
		}
	}

	instruct psx.WRAM_WRITE par{
		any{
			psx.Word==1 : any{
				psx.A<0>==0b0 : sdram_write(0b00000 || psx.A<20:1>, 128#psx.Dout<7:0>,      0x0001, 1);
				psx.A<0>==0b1 : sdram_write(0b00000 || psx.A<20:1>, (128#psx.Dout<7:0>)<<8, 0x0002, 1);
			}
			psx.Word==2 : par{
				sdram_write(0b00000 || psx.A<20:1>, 128#psx.Dout<15:0>, 0x0003, 1);
			}
			else/*psx.Word==4*/ : sdram_write(0b00000 || psx.A<20:2> || 0b0, 128#psx.Dout, 0x000F, 2);
		}
	}

	// 0b01_0000_0aaa_aaaa_aaaa_aaaa_aa00
	instruct psx.BIOS_READ par{
		any{
			(psx.Word==1) | (psx.Word==2) : par{
				sdram_read(0b0100000 || psx.A<18:1>, 1);
			}
			else : par{// byte 4 -> burst 2
				sdram_read(0b0100000 || psx.A<18:2> || 0b0, 2);//psx.Word<4:1>);
			}
		}
		psx_Word := psx.Word;
		psx_A := psx.A;
	}
	if(sdram_ack) psx.bios_ack();

	reg_wr gpu_read_wait_ack, gpu_write_wait_ack;
	reg_wr spu_wait_ack;

	alt{
		gpu_read_wait_ack | gpu_write_wait_ack | 
		spu_wait_ack | ^sdram_ack : ;

		psx.vram_read_req : par{
			sdram_read(0b000010 || psx.vram_adrs, 0b0 || psx.vram_burst);
			gpu_read_wait_ack := 0b1;
		}

		psx.vram_write_req : par{
			sdram_write(0b000010 || psx.vram_adrs, 128#psx.vram_write_data, 0x0003, 1);
			gpu_write_wait_ack := 0b1;
		}

/*
		psx.spu_mem_read_req : par{
halt(0x95);
			sdram_read_L(0b000100 || psx.spu_mem_A);
			spu_wait_ack := 0b1;
		}

		psx.spu_mem_write_req : par{
halt(0x96);
			sdram_write_L(0b000100 || psx.spu_mem_A, 0x0000 || psx.spu_mem_Din, 0b0011);
			spu_wait_ack := 0b1;
		}
*/
	}

	psx.vram_read_data = sdram_dout<63:0>;

	if(gpu_read_wait_ack & sdram_ack){
		psx.vram_read_ack();
		gpu_read_wait_ack := 0b0;
	}

	if(gpu_write_wait_ack & sdram_ack){
		psx.vram_write_ack();
		gpu_write_wait_ack := 0b0;
	}

/*
	psx.spu_mem_Dout = sdram_rdata<15:0>;

	if(spu_wait_ack){
		if(sdram_ack){
			psx.spu_mem_ack();
			spu_wait_ack := 0b0;
		}
	}
*/
//	if(psx.sw_spu_off) psx.spu_mem_ack();

	instruct psx.kernel_ok par{
		exe_read_ok := 0b0;
		generate exe_read.do();
	}

	// BIOS 0b0100_0000_0000_0000_0000_0000
	// 0x00400000 -> 0x01000000
	stage apf2sdram {
		first_state st1;
		state st1 par{
			reg_wr wait_count<4>;
			wait_count++;
			if(/&wait_count) goto st2;
		}
		state st2 if(sdram_ack){
			set_sdram_reg := 0b1;
			goto st3;
		}
		state st3 if(target_dataslot_read){
			set_sdram_reg := 0b0;
			goto st4;
		}
		state st4 if(^ram_reloading){
			reg_wr file_checked;
			if(^file_checked){
				generate check_file.do();
				file_checked := 0b1;
			}
			goto st1;
			finish;
		}
	}

// bin 0x12345678
// wdata 78 56 34 12
// sram0 34 12
// sram2 78 56
	stage check_file {
		first_state st1;
		state st1 par{
			// スロットID、スロット内バイトオフセット、バイト数
			generate apf2sram.do(0x0040, 2, 2);
			goto st2;
		}
		state st2 if(^apf2sram.do & sram.ack){
// 0 0x5350
// 1 0x2D53
// 2 0x582D
			if(sram.dout==0x3C08) f_bios := 0b1; // 0x1300083C
			if(sram.dout==0x582D) f_exe := 0b1; // "PS-X" 0x50532D58
			generate wram_clear.do();
			finish;
		}
	}

	stage wram_clear {
		first_state st1;
		state st1 if(sdram_ack){
			reg_wr wA<19>;
			sdram_write(0b00000 || wA || 0b0, 128#0b0, 0x000F , 2);
			wA++;
			if(/&wA) goto st2;
		}
		state st2 if(sdram_ack){
			if(psx.sw_cdrom_ctrl==0b00){ // for ROM-image
				generate rom_read.do();
			}
			exe_read_ok := 0b1;
			finish;
		}
	}
/*
	stage apf2bram {
		first_state st1;
		state st1 par{
			set_bram_reg := 0b1;
			goto st2;
		}
		state st2 if(target_dataslot_read){
			set_bram_reg := 0b0;
			goto st3;
		}
		state st3 if(bram_word_wr | ^ram_reloading){
			reg_wr adrs<10>; // 0x3FF
			file_ram.write(adrs, bram_wdata);
			adrs++;
			if(/&adrs) goto st4;
		}
		state st4 if(^ram_reloading){
			file_ram.read(0);
			goto st1;
			finish;
		}
	}
*/
	stage apf2sram {
//		reg_wr sram_wadrs<10>; // 1kWord 4kByte
		reg_wr sram_wadrs<11>; // 2kWord 8kByte
		first_state st1;
		state st1 par{
			set_sram_reg := 0b1;
			goto st2;
		}
		state st2 if(target_dataslot_read){
			set_sram_reg := 0b0;
			goto st3;
		}
		state st3 if((sram_word_wr | ^ram_reloading) & sram.ack){
			sram.write(0b00000 || sram_wadrs || 0b0, sram_wdata<15:0>);
			goto st4;
		}
		state st4 if(sram.ack){
			sram.write(0b00000 || sram_wadrs || 0b1, sram_wdata<31:16>);
			sram_wadrs++;
			if(/&sram_wadrs) goto st5;
			else goto st3;
		}
		state st5 if(^ram_reloading & sram.ack){
			sram.read(0);
			goto st1;
			finish;
		}
	}

	stage rom_read {
		reg_ws file_adrs<17>;
		first_state st_read;
		state st_read if(psx.file_read_req & ^apf2sram.do & sram.ack){
			// 783216000 Byte = 0x2EAEED80 -> 0x40000000 30bit
			if(psx.file_adrs<29:13>==file_adrs){
				sram.read(0b00000 || psx.file_adrs<12:1>);
				goto st_data;
			}
			else{
				generate apf2sram.do(0x0040, 0b00 || psx.file_adrs<29:13> || 13#0b0, 8192);
				file_adrs := psx.file_adrs<29:13>;
			}
		}
		state st_data if(sram.ack){
			switch(psx.file_adrs<0>){
				case 0: psx.file_data = sram.dout<7:0>;
				case 1: psx.file_data = sram.dout<15:8>;
			}
			psx.file_ack();
			goto st_read;
		}
	}

	stage exe_read {
		reg_wr text_start<21>, text_size<21>; // ram 2MB
		first_state st_open;
		state st_open par{
			generate apf2sram.do(0x0040, 0, 0x00000100);
			goto st_head;
		}
		state st_head if(^apf2sram.do & sram.ack){
			reg_wr h_adrs<8>; // 0xFF<8>
			sel h_data<8>;
			switch(h_adrs<0>){
				case 0: h_data = sram.dout<7:0>;
				case 1: h_data = sram.dout<15:8>;
			}
			psx.exe_set(0x0 || h_adrs, h_data);

			any{
				h_adrs==0x18 : text_start := 0b00000 || sram.dout;
				h_adrs==0x1A : text_start := sram.dout<4:0> || text_start<15:0>;
				h_adrs==0x1C : text_size := 0b00000 || sram.dout;
				h_adrs==0x1E : text_size := sram.dout<4:0> || text_size<15:0>;
			}

			sel h_adrs_inc<8>;
			h_adrs_inc = h_adrs + 0x01;
			sram.read(0b0000000000 || h_adrs_inc<7:1>);
			h_adrs := h_adrs_inc;
			if(h_adrs==0xFF) goto st_text;
		}
		state st_text par{
			generate apf2sdram.do(0x0040, 0x00000800, 11#0b0 || text_start, 11#0b0 || text_size);
			goto st_end;
		}
		state st_end if(^apf2sdram.do){
			exe_read_ok := 0b1;
			finish;
		}
	}

}
