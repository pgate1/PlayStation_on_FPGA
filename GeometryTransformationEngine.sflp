/*
	GTE top
		by pgate1
*/

declare mul_s16 interface
{
	input a<16>, b<16>;
	output dout<32>;
	instrin con;
	instr_arg con(a, b);
}

declare mul_s32 interface
{
	input a<32>, b<32>;
	output dout<64>;
	instrin con;
	instr_arg con(a, b);
}

%i "gte_LIMIT.h"
%i "gte_DIVIDE.h"

circuit GeometryTransformationEngine
{
	input rt_data<32>, rd<5>, op<32>;
	instrin MFC2(rd), CFC2(rd), MTC2(rt_data, rd), CTC2(rt_data, rd);
	output dout<32>;
	reg dout_reg<32>;

	instrin RTPS, RTPT, MVMVA, DPCS, DPCT, INTPL, SQR, NCS, NCT, NCDS, NCDT, NCCS, NCCT, CC, NCLIP, AVSZ3, AVSZ4, OP, GPF, GPL;

	reg rt_value<32>, rd_reg<5>;
	output running;

	reg_ws reset;
	mem d[32]<32> = {0};
	mem c[32]<32> = {0};

	sel s_FLAG<32>; instrself set_FLAG(s_FLAG), reset_FLAG;
//	instrself SUM_FLAG;

	sel s_VX<5>, VX<16>; instrself get_VX(s_VX);
	sel s_VY<5>, VY<16>; instrself get_VY(s_VY);
	sel s_VZ<5>, VZ<16>; instrself get_VZ(s_VZ);
	sel s_MX11<2>, MX11<16>; instrself get_MX11(s_MX11);
	sel s_MX12<2>, MX12<16>; instrself get_MX12(s_MX12);
	sel s_MX13<2>, MX13<16>; instrself get_MX13(s_MX13);
	sel s_MX21<2>, MX21<16>; instrself get_MX21(s_MX21);
	sel s_MX22<2>, MX22<16>; instrself get_MX22(s_MX22);
	sel s_MX23<2>, MX23<16>; instrself get_MX23(s_MX23);
	sel s_MX31<2>, MX31<16>; instrself get_MX31(s_MX31);
	sel s_MX32<2>, MX32<16>; instrself get_MX32(s_MX32);
	sel s_MX33<2>, MX33<16>; instrself get_MX33(s_MX33);
	sel s_CV1<2>, CV1<32>; instrself get_CV1(s_CV1);
	sel s_CV2<2>, CV2<32>; instrself get_CV2(s_CV2);
	sel s_CV3<2>, CV3<32>; instrself get_CV3(s_CV3);
	sel s_fSX<5>, s_fSX_val<16>; instrself set_fSX(s_fSX, s_fSX_val);
	sel s_fSY<5>, s_fSY_val<16>; instrself set_fSY(s_fSY, s_fSY_val);
	sel s_fSZ<5>, s_fSZ_val<16>; instrself set_fSZ(s_fSZ, s_fSZ_val);
	sel s_OTZ<16>; instrself set_OTZ(s_OTZ);
	sel s_IR0<16>; instrself set_IR0(s_IR0);
	sel s_IR1<16>; instrself set_IR1(s_IR1);
	sel s_IR2<16>; instrself set_IR2(s_IR2);
	sel s_IR3<16>; instrself set_IR3(s_IR3);
	sel s_SXY0<32>; instrself set_SXY0(s_SXY0);
	sel s_SXY1<32>; instrself set_SXY1(s_SXY1);
	sel s_SXY2<32>; instrself set_SXY2(s_SXY2);
	sel s_SXYP<32>; instrself set_SXYP(s_SXYP);
	sel s_SZ0<16>; instrself set_SZ0(s_SZ0);
	sel s_SZ1<16>; instrself set_SZ1(s_SZ1);
	sel s_SZ2<16>; instrself set_SZ2(s_SZ2);
	sel s_SZ3<16>; instrself set_SZ3(s_SZ3);
	sel s_RGB0<32>; instrself set_RGB0(s_RGB0);
	sel s_RGB1<32>; instrself set_RGB1(s_RGB1);
//	sel s_R2<8>; instrself set_R2(s_R2);
//	sel s_G2<8>; instrself set_G2(s_G2);
//	sel s_B2<8>; instrself set_B2(s_B2);
//	sel s_CODE2<8>; instrself set_CODE2(s_CODE2);
	sel s_MAC0<32>; instrself set_MAC0(s_MAC0);
	sel s_MAC1<32>; instrself set_MAC1(s_MAC1);
	sel s_MAC2<32>; instrself set_MAC2(s_MAC2);
	sel s_MAC3<32>; instrself set_MAC3(s_MAC3);
	sel s_IRGB<32>; instrself set_IRGB(s_IRGB);

//	sel s_BOUNDS1<64>;
//	instrself BOUNDS1(s_BOUNDS1);

	sel limE_val<32>, limE_ret<32>; instrself limE(limE_val);

//	sel F_val<64>, F_ret<64>; instrself F(F_val);
	sel limG1_val<32>, limG1_ret<16>; instrself limG1(limG1_val);
	sel limG2_val<32>, limG2_ret<16>; instrself limG2(limG2_val);
	sel limH_val<32>, limH_ret<16>; instrself limH(limH_val);

	mul_s16 smul_mac1_1, smul_mac1_2, smul_mac1_3,
		    smul_mac2_1, smul_mac2_2, smul_mac2_3,
		    smul_mac3_1, smul_mac3_2, smul_mac3_3;

	mul_s16 smul_mac1, smul_mac2, smul_mac3;

	gte_DIVIDE divide;

	sel h_code<8>;
	instrself halt(h_code);
	reg_wr halt_code_reg<8>;
	output halt_code<8>;

output dbg<8>;
reg_wr dbg_reg<8>;
//output dbg16<16>;
//reg_wr dbg16_reg<16>;
//output dbg32<32>;
//reg_wr dbg32_reg<32>;
//reg crand<24> = 1;

	stage_name MFC2_stg { task do(rd_reg); }
	stage_name CFC2_stg { task do(rd_reg); }
	stage_name MTC2_stg { task do(rt_value, rd_reg); }
	stage_name CTC2_stg { task do(rt_value, rd_reg); }

	reg_wr MACtoIR_limB_lim;
	stage_name MACtoIR { task do(MACtoIR_limB_lim); }
	stage_name MACtoCODE2 { task do(); }

	stage_name RTP_stg { task rtpt(); task rtps(); }
	stage_name MVMVA_stg { task do(); }
	stage_name DPC_stg { task dpcs(); task dpct(); }
	stage_name INTPL_stg { task do(); }
	stage_name SQR_stg { task do(); }
	stage_name NC_stg { task ncs(); task nct(); }
	stage_name NCD_stg { task ncds(); task ncdt(); }
	stage_name NCC_stg { task nccs(); task ncct(); }
	stage_name CC_stg { task do(); }
	stage_name NCLIP_stg { task do(); }
	stage_name AVSZ3_stg { task do(); }
	stage_name AVSZ4_stg { task do(); }
	stage_name OP_stg { task do(); }
	stage_name GPF_stg { task do(); }
	stage_name GPL_stg { task do(); }

	instruct halt halt_code_reg := h_code;
	halt_code = halt_code_reg;

dbg = dbg_reg;
//dbg16 = dbg16_reg;
//dbg32 = dbg32_reg;

	if(reset){
		par(i=0;i<32;i++){
			d[i] := 0; c[i] := 0;
		}
		reset := 0b0;
	}

	instruct MFC2 generate MFC2_stg.do(rd);
	instruct CFC2 generate CFC2_stg.do(rd);
	instruct MTC2 generate MTC2_stg.do(rt_data, rd);
	instruct CTC2 generate CTC2_stg.do(rt_data, rd);

	instruct RTPS generate RTP_stg.rtps();
	instruct RTPT generate RTP_stg.rtpt();
	instruct MVMVA generate MVMVA_stg.do();
	instruct DPCS generate DPC_stg.dpcs();
	instruct DPCT generate DPC_stg.dpct();
	instruct INTPL generate INTPL_stg.do();
	instruct SQR generate SQR_stg.do();
	instruct NCS generate NC_stg.ncs();
	instruct NCT generate NC_stg.nct();
	instruct NCDS generate NCD_stg.ncds();
	instruct NCDT generate NCD_stg.ncdt();
	instruct NCCS generate NCC_stg.nccs();
	instruct NCCT generate NCC_stg.ncct();
	instruct CC generate CC_stg.do();
	instruct NCLIP generate NCLIP_stg.do();
	instruct AVSZ3 generate AVSZ3_stg.do();
	instruct AVSZ4 generate AVSZ4_stg.do();
	instruct OP generate OP_stg.do();
	instruct GPF generate GPF_stg.do();
	instruct GPL generate GPL_stg.do();

	running = MFC2_stg.do | CFC2_stg.do | MTC2_stg.do | CTC2_stg.do |
		RTP_stg.rtps | RTP_stg.rtpt |
		MVMVA_stg.do | 
		DPC_stg.dpcs | DPC_stg.dpct |
		INTPL_stg.do |
		SQR_stg.do | 
		NC_stg.ncs | NC_stg.nct |
		NCD_stg.ncds | NCD_stg.ncdt |
		NCC_stg.nccs | NCC_stg.ncct |
		CC_stg.do | NCLIP_stg.do |
		AVSZ3_stg.do | AVSZ4_stg.do |
		OP_stg.do | GPF_stg.do | GPL_stg.do;

	dout = dout_reg;
/*
	instruct SUM_FLAG par{
		if((c[31] & 0x7F87E000)!=0) c[31] |= 0x80000000;
	}
*/
	sel VX0<16>; VX0 = d[0]<15:0>;
	sel VY0<16>; VY0 = d[0]<31:16>;
	sel VZ0<16>; VZ0 = d[1]<15:0>;
	sel R<8>; R = d[6]<7:0>;
	sel G<8>; G = d[6]<15:8>;
	sel B<8>; B = d[6]<23:16>;
	sel CODE<8>; CODE = d[6]<31:24>;
	sel IR0<16>; IR0 = d[8]<15:0>;
	sel IR1<16>; IR1 = d[9]<15:0>;
	sel IR2<16>; IR2 = d[10]<15:0>;
	sel IR3<16>; IR3 = d[11]<15:0>;
	sel SX0<16>; SX0 = d[12]<15:0>;
	sel SY0<16>; SY0 = d[12]<31:16>;
	sel SXY1<32>; SXY1 = d[13];
	sel SX1<16>; SX1 = d[13]<15:0>;
	sel SY1<16>; SY1 = d[13]<31:16>;
	sel SXY2<32>; SXY2 = d[14];
	sel SX2<16>; SX2 = d[14]<15:0>;
	sel SY2<16>; SY2 = d[14]<31:16>;
	sel SZ0<16>; SZ0 = d[16]<15:0>;
	sel SZ1<16>; SZ1 = d[17]<15:0>;
	sel SZ2<16>; SZ2 = d[18]<15:0>;
	sel SZ3<16>; SZ3 = d[19]<15:0>;
	sel R0<8>; R0 = d[20]<7:0>;
	sel G0<8>; G0 = d[20]<15:8>;
	sel B0<8>; B0 = d[20]<23:16>;
	sel RGB1<32>; RGB1 = d[21];
	sel RGB2<32>; RGB2 = d[22];
	sel MAC0<32>; MAC0 = d[24];
	sel MAC1<32>; MAC1 = d[25];
	sel MAC2<32>; MAC2 = d[26];
	sel MAC3<32>; MAC3 = d[27];
	sel R11<16>; R11 = c[0]<15:0>;
	sel R12<16>; R12 = c[0]<31:16>;
	sel R13<16>; R13 = c[1]<15:0>;
	sel R21<16>; R21 = c[1]<31:16>;
	sel R22<16>; R22 = c[2]<15:0>;
	sel R23<16>; R23 = c[2]<31:16>;
	sel R31<16>; R31 = c[3]<15:0>;
	sel R32<16>; R32 = c[3]<31:16>;
	sel R33<16>; R33 = c[4]<15:0>;
	sel TRX<32>; TRX = c[5];
	sel TRY<32>; TRY = c[6];
	sel TRZ<32>; TRZ = c[7];
	sel L11<16>; L11 = c[8]<15:0>;
	sel L12<16>; L12 = c[8]<31:16>;
	sel L13<16>; L13 = c[9]<15:0>;
	sel L21<16>; L21 = c[9]<31:16>;
	sel L22<16>; L22 = c[10]<15:0>;
	sel L23<16>; L23 = c[10]<31:16>;
	sel L31<16>; L31 = c[11]<15:0>;
	sel L32<16>; L32 = c[11]<31:16>;
	sel L33<16>; L33 = c[12]<15:0>;
	sel RBK<32>; RBK = c[13];
	sel GBK<32>; GBK = c[14];
	sel BBK<32>; BBK = c[15];
	sel LR1<16>; LR1 = c[16]<15:0>;
	sel LR2<16>; LR2 = c[16]<31:16>;
	sel LR3<16>; LR3 = c[17]<15:0>;
	sel LG1<16>; LG1 = c[17]<31:16>;
	sel LG2<16>; LG2 = c[18]<15:0>;
	sel LG3<16>; LG3 = c[18]<31:16>;
	sel LB1<16>; LB1 = c[19]<15:0>;
	sel LB2<16>; LB2 = c[19]<31:16>;
	sel LB3<16>; LB3 = c[20]<15:0>;
	sel RFC<32>; RFC = c[21];
	sel GFC<32>; GFC = c[22];
	sel BFC<32>; BFC = c[23];
	sel OFX<32>; OFX = c[24];
	sel OFY<32>; OFY = c[25];
	sel H<16>; H = c[26]<15:0>;
	sel DQA<16>; DQA = c[27]<15:0>;
	sel DQB<32>; DQB = c[28];
	sel ZSF3<16>; ZSF3 = c[29]<15:0>;
	sel ZSF4<16>; ZSF4 = c[30]<15:0>;

	// #define VX(n) (n < 3 ? CP2D.p[n << 1].sw.l : CP2D.p[9].sw.l)
	instruct get_VX if(s_VX!=3) VX = d[s_VX<<1]<15:0>; else VX = d[9]<15:0>;

	// #define VY(n) (n < 3 ? CP2D.p[n << 1].sw.h : CP2D.p[10].sw.l)
	instruct get_VY if(s_VY!=3) VY = d[s_VY<<1]<31:16>; else VY = d[10]<15:0>;

	// #define VZ(n) (n < 3 ? CP2D.p[(n << 1) + 1].sw.l : CP2D.p[11].sw.l)
	instruct get_VZ if(s_VZ!=3) VZ = d[(s_VZ<<1)+1]<15:0>; else VZ = d[11]<15:0>;

	// #define MX11(n) (n < 3 ? CP2C.p[(n << 3)].sw.l : 0)
	instruct get_MX11 if(s_MX11!=3) MX11 = c[s_MX11||0b000]<15:0>; else MX11 = 0;

	// #define MX12(n) (n < 3 ? CP2C.p[(n << 3)].sw.h : 0)
	instruct get_MX12 if(s_MX12!=3) MX12 = c[s_MX12||0b000]<31:16>; else MX12 = 0;

	// #define MX13(n) (n < 3 ? CP2C.p[(n << 3) + 1].sw.l : 0)
	instruct get_MX13 if(s_MX13!=3) MX13 = c[s_MX13||0b001]<15:0>; else MX13 = 0;

	// #define MX21(n) (n < 3 ? CP2C.p[(n << 3) + 1].sw.h : 0)
	instruct get_MX21 if(s_MX21!=3) MX21 = c[s_MX21||0b001]<31:16>; else MX21 = 0;

	// #define MX22(n) (n < 3 ? CP2C.p[(n << 3) + 2].sw.l : 0)
	instruct get_MX22 if(s_MX22!=3) MX22 = c[s_MX22||0b010]<15:0>; else MX22 = 0;

	// #define MX23(n) (n < 3 ? CP2C.p[(n << 3) + 2].sw.h : 0)
	instruct get_MX23 if(s_MX23!=3) MX23 = c[s_MX23||0b010]<31:16>; else MX23 = 0;

	// #define MX31(n) (n < 3 ? CP2C.p[(n << 3) + 3].sw.l : 0)
	instruct get_MX31 if(s_MX31!=3) MX31 = c[s_MX31||0b011]<15:0>; else MX31 = 0;

	// #define MX32(n) (n < 3 ? CP2C.p[(n << 3) + 3].sw.h : 0)
	instruct get_MX32 if(s_MX32!=3) MX32 = c[s_MX32||0b011]<31:16>; else MX32 = 0;

	// #define MX33(n) (n < 3 ? CP2C.p[(n << 3) + 4].sw.l : 0)
	instruct get_MX33 if(s_MX33!=3) MX33 = c[s_MX33||0b100]<15:0>; else MX33 = 0;

	// #define CV1(n) (n < 3 ? (s32)CP2C.r[(n << 3) + 5] : 0)
	instruct get_CV1 if(s_CV1!=3) CV1 = c[s_CV1||0b101]; else CV1 = 0;

	// #define CV2(n) (n < 3 ? (s32)CP2C.r[(n << 3) + 6] : 0)
	instruct get_CV2 if(s_CV2!=3) CV2 = c[s_CV2||0b110]; else CV2 = 0;

	// #define CV3(n) (n < 3 ? (s32)CP2C.r[(n << 3) + 7] : 0)
	instruct get_CV3 if(s_CV3!=3) CV3 = c[s_CV3||0b111]; else CV3 = 0;

	// #define fSX(n) ((CP2D.p)[((n) + 12)].sw.l)
	instruct set_fSX d[s_fSX+12] := d[s_fSX+12]<31:16> || s_fSX_val;

	// #define fSY(n) ((CP2D.p)[((n) + 12)].sw.h)
	instruct set_fSY d[s_fSY+12] := s_fSY_val || d[s_fSY+12]<15:0>;

	// #define fSZ(n) ((CP2D.p)[((n) + 17)].w.l)
	instruct set_fSZ d[s_fSZ+17] := d[s_fSZ+17]<31:16> || s_fSZ_val;

/*
	// #define A1(a) BOUNDS((a), 0x7fffffff, (1 << 30), -(s64)0x80000000, (1 << 27))
	instruct BOUNDS1 par{
		if((0x000000007FFFFFFF-s_BOUNDS1)<63>){ // s_BOUNDS > 0x000000007FFFFFFF
			FLAG |= 0x40000000;
		}
		else{
			if((s_BOUNDS1-0xFFFFFFFF80000000)<63>){ // s_BOUNDS < 0xFFFFFFFF80000000
				FLAG |= 0x08000000;
			}
		}
	}
	// #define A2(a) BOUNDS((a), 0x7fffffff, (1 << 29), -(s64)0x80000000, (1 << 26))
	// #define A3(a) BOUNDS((a), 0x7fffffff, (1 << 28), -(s64)0x80000000, (1 << 25))
*/

	instruct set_OTZ d[7] := d[7]<31:16> || s_OTZ;
	instruct set_IR0 d[8] := d[8]<31:16> || s_IR0;
	instruct set_IR1 d[9] := d[9]<31:16> || s_IR1;
	instruct set_IR2 d[10] := d[10]<31:16> || s_IR2;
	instruct set_IR3 d[11] := d[11]<31:16> || s_IR3;

	instruct limE par{
	//	if(limE_val<31:17>!=0){ // result > 0x0001FFFF
		if(limE_val<31>){ // result == 0xFFFFFFFF
			set_FLAG(0x00020000);
			limE_ret = 0x0001FFFF;
		}
		else limE_ret = limE_val;
	}

	// #define F(a) BOUNDS((a), 0x7fffffff, (1 << 16), -(s64)0x80000000, (1 << 15))

	// #define limG1(a) LIM((a), 0x3ff, -0x400,(1 << 14))
	instruct limG1 any{
		(limG1_val<31>==0b0) & (limG1_val<30:10>!=0) : par{ // value > 0x000003FF
			set_FLAG(0x00004000);
			limG1_ret = 0x03FF;
		}
		(limG1_val<31>==0b1) & (limG1_val<30:10>!=(21#0b1)) : par{ // value < 0xFFFFFC00
			set_FLAG(0x00004000);
			limG1_ret = 0xFC00;
		}
		else : limG1_ret = limG1_val<15:0>;
	}
	// #define limG2(a) LIM((a), 0x3ff, -0x400, (1 << 13))
	instruct limG2 any{
		(limG2_val<31>==0b0) & (limG2_val<30:10>!=0) : par{ // value > 0x000003FF
			set_FLAG(0x00002000);
			limG2_ret = 0x03FF;
		}
		(limG2_val<31>==0b1) & (limG2_val<30:10>!=(21#0b1)) : par{ // value < 0xFFFFFC00
			set_FLAG(0x00002000);
			limG2_ret = 0xFC00;
		}
		else : limG2_ret = limG2_val<15:0>;
	}
	// #define limH(a) LIM((a), 0x1000, 0x0000, (1 << 12))

	instruct limH any{
		(0x00001000-limH_val)<31> : par{ // value > 0x00001000
			set_FLAG(0x00001000);
			limH_ret = 0x1000;
		}
		limH_val<31> : par{ // value < 0
			set_FLAG(0x00001000);
			limH_ret = 0x0000;
		}
		else : limH_ret = limH_val<15:0>;
	}

	instruct set_SXY0 d[12] := s_SXY0;
	instruct set_SXY1 d[13] := s_SXY1;
	instruct set_SXY2 d[14] := s_SXY2;
	instruct set_SXYP d[15] := s_SXYP;
	instruct set_SZ0 d[16] := d[16]<31:16> || s_SZ0;
	instruct set_SZ1 d[17] := d[17]<31:16> || s_SZ1;
	instruct set_SZ2 d[18] := d[18]<31:16> || s_SZ2;
	instruct set_SZ3 d[19] := d[19]<31:16> || s_SZ3;
	instruct set_RGB0 d[20] := s_RGB0;
	instruct set_RGB1 d[21] := s_RGB1;
//	instruct set_R2 d[22] := d[22]<31:8> || s_R2;
//	instruct set_G2 d[22] := d[22]<31:16> || s_G2 || d[22]<7:0>;
//	instruct set_B2 d[22] := d[22]<31:24> || s_B2 || d[22]<15:0>;
//	instruct set_CODE2 d[22] := s_CODE2 || d[22]<23:0>;
	instruct set_MAC0 d[24] := s_MAC0;
	instruct set_MAC1 d[25] := s_MAC1;
	instruct set_MAC2 d[26] := s_MAC2;
	instruct set_MAC3 d[27] := s_MAC3;
	instruct set_IRGB d[28] := s_IRGB;
	instruct set_FLAG c[31] |= s_FLAG;
	instruct reset_FLAG c[31] := 0x00000000;

	stage MFC2_stg {
		par{
			sel value<32>;
			any{
				(rd_reg==1) | (rd_reg==3) | (rd_reg==5) | (rd_reg==8) |
				(rd_reg==9) | (rd_reg==10) | (rd_reg==11) : par{
					// CP2D.r[reg] = (s32)(s16)CP2D.p[reg].sw.l;
					value = 32#d[rd_reg]<15:0>;
					d[rd_reg] := value;
				}
				(rd_reg==7) | (rd_reg==16) | (rd_reg==17) |
				(rd_reg==18) | (rd_reg==19) : par{
					// CP2D.r[reg] = (u32)(u16)CP2D.p[reg].w.l;
					value = 0x0000 || d[rd_reg]<15:0>;
					d[rd_reg] := value;
				}
				(rd_reg==15) : par{
					// CP2D.r[reg] = gteSXY2;
					value = SXY2;
					d[rd_reg] := value;
				}
				(rd_reg==28) | (rd_reg==29) : par{
/*
			CP2D.r[reg] = LIM(IR1 >> 7, 0x1F, 0, 0) |
						(LIM(IR2 >> 7, 0x1F, 0, 0) << 5) |
						(LIM(IR3 >> 7, 0x1F, 0, 0) << 10);
*/
 // 0000111110000000
					sel lim_ir1<5>;
					any{
						(IR1<15>==0b0) & (IR1<14:12>!=0b000) : lim_ir1 = 0b11111;
						(IR1<15>==0b1) : lim_ir1 = 0b00000;
						else : lim_ir1 = IR1<11:7>;
					}
					sel lim_ir2<5>;
					any{
						(IR2<15>==0b0) & (IR2<14:12>!=0b000) : lim_ir2 = 0b11111;
						(IR2<15>==0b1) : lim_ir2 = 0b00000;
						else : lim_ir2 = IR2<11:7>;
					}
					sel lim_ir3<5>;
					any{
						(IR3<15>==0b0) & (IR3<14:12>!=0b000) : lim_ir3 = 0b11111;
						(IR3<15>==0b1) : lim_ir3 = 0b00000;
						else : lim_ir3 = IR3<11:7>;
					}

					value = 17#0b0 || lim_ir3 || lim_ir2 || lim_ir1;
					d[rd_reg] := value;
				}
				else : value = d[rd_reg];
			}
			dout_reg := value;
			finish;
		}
	}

	stage CFC2_stg {
		par{
			if(rd_reg==31){
			//	SUM_FLAG();
				sel value<32>;
				value = ((c[31] & 0x7F87E000)!=0) || c[31]<30:0>;
				c[31] := value;
				dout_reg := value;
			}
			else{
				dout_reg := c[rd_reg];
			}
			finish;
		}
	}

	stage MTC2_stg {
		par{
			any{
				rd_reg==15 : par{
					set_SXY0(SXY1);
					set_SXY1(SXY2);
					set_SXY2(rt_value);
					set_SXYP(rt_value);
				}
				rd_reg==28 : par{
					set_IR1(4#0b0 || rt_value<4:0> || 7#0b0);
					set_IR2(4#0b0 || rt_value<9:5> || 7#0b0);
					set_IR3(4#0b0 || rt_value<14:10> || 7#0b0);
					set_IRGB(rt_value);
				}
				rd_reg==30 : par{
					// LZCS = value;
					d[30] := rt_value;
					// Count Leading Zero
					sel val<32>, bitp<6>;
					if(rt_value<31>==0b0) val =  rt_value; // value >= 0
					                 else val = ^rt_value; // value <  0
					alt(i=0;i<32;i++){
						val<31-i> : bitp = 0b0 || i;
						else : bitp = 32;
					}
					// LZCR = i; 1Å`32
					d[31] := 26#0b0 || bitp;
				}
				rd_reg==31 : ;
				else : d[rd_reg] := rt_value;
			}
			finish;
		}
	}

	stage CTC2_stg {
		par{
			sel value<32>;
			any{
				(rd_reg== 4) | (rd_reg==12) | (rd_reg==20) | (rd_reg==26) |
				(rd_reg==27) | (rd_reg==29) | (rd_reg==30) : par{
					// value = (s32)(s16)value;
					value = 32#rt_value<15:0>;
				}
				rd_reg==31 : par{
					value = rt_value & 0x7FFFF000;
				//	value = ((rt_value & 0x7F87E000)!=0) || (rt_value & 0x7FFFF000)<30:0>;
				}
				else : value = rt_value;
			}
			c[rd_reg] := value;
			finish;
		}
	}

	stage MACtoIR {
		gte_LIMIT lim_MACtoIR;
		par{
			if(0b0){
				lim_MACtoIR.limC1(0); lim_MACtoIR.limC2(0); lim_MACtoIR.limC3(0);
				lim_MACtoIR.limD(0);
			}

			instruct lim_MACtoIR.set_FLAG set_FLAG(lim_MACtoIR.FLAG);

			// IR1 = limB1(MAC1, lim);
			set_IR1(lim_MACtoIR.limB1(MAC1, MACtoIR_limB_lim).limB1_ret);
			// IR2 = limB2(MAC2, lim);
			set_IR2(lim_MACtoIR.limB2(MAC2, MACtoIR_limB_lim).limB2_ret);
			// IR3 = limB3(MAC3, lim);
			set_IR3(lim_MACtoIR.limB3(MAC3, MACtoIR_limB_lim).limB3_ret);

			finish;
		}
	}

	stage MACtoCODE2 {
		gte_LIMIT lim_MACtoCODE2;
		par{
			instruct lim_MACtoCODE2.set_FLAG set_FLAG(lim_MACtoCODE2.FLAG);
			if(0b0){
				lim_MACtoCODE2.limB1(0,0); lim_MACtoCODE2.limB2(0,0); lim_MACtoCODE2.limB3(0,0);
				lim_MACtoCODE2.limD(0);
			}

			// RGB0 = RGB1;
			set_RGB0(RGB1);
			// RGB1 = RGB2;
			set_RGB1(RGB2);

			// CODE2 = CODE;
		//	set_CODE2(CODE);
			// R2 = limC1(MAC1 >> 4);
		//	set_R2(limC1((MAC1>>4)<15:0>).limC1_ret);
			// G2 = limC2(MAC2 >> 4);
		//	set_G2(limC2((MAC2>>4)<15:0>).limC2_ret);
			// B2 = limC3(MAC3 >> 4);
		//	set_B2(limC3((MAC3>>4)<15:0>).limC3_ret);
			d[22] :=
				CODE ||
				lim_MACtoCODE2.limC3(32#MAC3<31:4>).limC3_ret ||
				lim_MACtoCODE2.limC2(32#MAC2<31:4>).limC2_ret ||
				lim_MACtoCODE2.limC1(32#MAC1<31:4>).limC1_ret;

			finish;
		}
	}

	stage RTP_stg { // RTPS RTPT
		reg_wr rtp_v<5>, rtp_vx<16>, rtp_vy<16>, rtp_vz<16>, szv<16>, quotient<32>;
		mul_s32 rtp_mulq_x, rtp_mulq_y, rtp_mulq_m;
		gte_LIMIT lim_RTP;
		first_state st_init;

		par{
			instruct lim_RTP.set_FLAG set_FLAG(lim_RTP.FLAG);
			if(0b0){
				lim_RTP.limB1(0,0); lim_RTP.limB2(0,0); lim_RTP.limB3(0,0);
				lim_RTP.limC1(0); lim_RTP.limC2(0); lim_RTP.limC3(0);
			}
		}

		state st_init par{
			reset_FLAG();
			if(RTP_stg.rtpt) set_SZ0(SZ3);
			rtp_v := 0;
			goto st_vset;
		}
		state st_vset par{
			rtp_vx := get_VX(rtp_v).VX;
			rtp_vy := get_VY(rtp_v).VY;
			rtp_vz := get_VZ(rtp_v).VZ;
			goto st_mac1;
		}
		state st_mac1 par{
/*
			MAC1 = 
				A1( (
						((s64)TRX << 12) +
						(R11 * vx) + (R12 * vy) + (R13 * vz)
				) >> 12 );
*/
			sel mac1_t<64>;
			mac1_t = 64#(
				(TRX || 0x000) + 
				44#smul_mac1_1.con(R11, rtp_vx).dout + 
				44#smul_mac1_2.con(R12, rtp_vy).dout + 
				44#smul_mac1_3.con(R13, rtp_vz).dout
				)<43:12>;
		//	A1(t);
			set_MAC1(mac1_t<31:0>);

			sel mac2_t<64>;
			mac2_t = 64#(
				(TRY || 0x000) + 
				44#smul_mac2_1.con(R21, rtp_vx).dout + 
				44#smul_mac2_2.con(R22, rtp_vy).dout + 
				44#smul_mac2_3.con(R23, rtp_vz).dout
				)<43:12>;
		//	A2(t);
			set_MAC2(mac2_t<31:0>);

			sel mac3_t<64>;
			mac3_t = 64#(
				(TRZ || 0x000) + 
				44#smul_mac3_1.con(R31, rtp_vx).dout + 
				44#smul_mac3_2.con(R32, rtp_vy).dout + 
				44#smul_mac3_3.con(R33, rtp_vz).dout
				)<43:12>;
		//	A3(t);
			set_MAC3(mac3_t<31:0>);

			generate MACtoIR.do(0b0);
			goto st_ir;
		}
		state st_ir par{
			// IR1 = limB1(MAC1, 0);
			// IR2 = limB2(MAC2, 0);
			// IR3 = limB3(MAC3, 0);

			// fSZ(v) = limD(MAC3);
			sel fszv<16>;
			fszv = lim_RTP.limD(MAC3).limD_ret;
			if(RTP_stg.rtps){
				set_SZ0(SZ1);
				set_SZ1(SZ2);
				set_SZ2(SZ3);
				set_SZ3(fszv);
				set_SXY0(SXY1);
				set_SXY1(SXY2);
				rtp_v := 2;
			}
			if(RTP_stg.rtpt){
				set_fSZ(rtp_v, fszv);
			}
			szv := fszv;

			divide.con0(H, fszv);
			goto st_div1;
		}
		state st_div1 par{
			divide.con1();
			goto st_div2;
		}
		state st_div2 par{
			divide.con2();
			goto st_div3;
		}
		state st_div3 par{
			// quotient = limE(DIVIDE(H, fSZ(v)));
			divide.con3(H, szv);
			quotient := limE(divide.dout).limE_ret;
			goto st_sx;
		}
		state st_sx par{
/*
			// fSX(v) = 
				limG1(
					F(
						(s64)OFX + ((s64)IR1 * quotient)
					) >> 16
				);
*/
			sel sx_f<64>;
			sx_f = (64#OFX) + rtp_mulq_x.con(32#IR1, quotient).dout;
		//	F(f);
			set_fSX(rtp_v, limG1(sx_f<32+16-1:16>).limG1_ret);

			goto st_sy;
		} // Ç±Ç±ÇÕïKóv
		state st_sy par{

			// fSY(v) = limG2(F((s64)OFY + ((s64)IR2 * quotient)) >> 16);
			sel sy_f<64>;
			sy_f = (64#OFY) + rtp_mulq_y.con(32#IR2, quotient).dout;
		//	F(f);
			set_fSY(rtp_v, limG2(sy_f<32+16-1:16>).limG2_ret);

			if(rtp_v==2) goto st_mac0;
			else goto st_vset;
			rtp_v++;
		}
		state st_mac0 par{
			// MAC0 = F((s64)(DQB + ((s64)DQA * quotient)) >> 12);
			sel f<64>;
			f = (64#DQB) + rtp_mulq_m.con(32#DQA, quotient).dout;
		//	F(f);
			set_MAC0(f<32+12-1:12>);
			goto st_ir0;
		}
		state st_ir0 par{
			// IR0 = limH(MAC0);
			set_IR0(limH(MAC0).limH_ret);
			goto st_init;
			finish;
		}
	}

	stage MVMVA_stg {
		sel mvmva_mx<2>, mvmva_v<2>, mvmva_cv<2>, mvmva_lm;
		reg_wr mvmva_vx<16>, mvmva_vy<16>, mvmva_vz<16>;
		first_state st_init;

		par{
			//shift = 12 * GTE_SF(op);
			//mx = GTE_MX(op);
			mvmva_mx = op<18:17>;
			//v = GTE_V(op);
			mvmva_v = op<16:15>;
			//cv = GTE_CV(op);
			mvmva_cv = op<14:13>;
			//lm = GTE_LM(op);
			mvmva_lm = op<10>;
		}

		state st_init par{
			reset_FLAG();
			mvmva_vx := get_VX(0b000||mvmva_v).VX;
			mvmva_vy := get_VY(0b000||mvmva_v).VY;
			mvmva_vz := get_VZ(0b000||mvmva_v).VZ;
			goto st_mac1;
		}
		state st_mac1 par{
/*
			MAC1 = A1((
				((s64)CV1(cv) << 12) +
				(MX11(mx) * vx) + (MX12(mx) * vy) + (MX13(mx) * vz)
			) >> shift);
*/
			sel mac1_t0<44>;
			mac1_t0 = (get_CV1(mvmva_cv).CV1 || 0x000) +
				44#smul_mac1_1.con(get_MX11(mvmva_mx).MX11, mvmva_vx).dout +
				44#smul_mac1_2.con(get_MX12(mvmva_mx).MX12, mvmva_vy).dout +
				44#smul_mac1_3.con(get_MX13(mvmva_mx).MX13, mvmva_vz).dout;
			sel mac1_t<32>;
			if(op<19>) mac1_t = mac1_t0<43:12>;
			else mac1_t = mac1_t0<31:0>;
			// A1(t);
			set_MAC1(mac1_t);

			// MAC2 = A2((((s64)CV2(cv) << 12) + (MX21(mx) * vx) + (MX22(mx) * vy) + (MX23(mx) * vz)) >> shift);
			sel mac2_t0<44>;
			mac2_t0 = (get_CV2(mvmva_cv).CV2 || 0x000) +
				44#smul_mac2_1.con(get_MX21(mvmva_mx).MX21, mvmva_vx).dout +
				44#smul_mac2_2.con(get_MX22(mvmva_mx).MX22, mvmva_vy).dout +
				44#smul_mac2_3.con(get_MX23(mvmva_mx).MX23, mvmva_vz).dout;
			sel mac2_t<32>;
			if(op<19>) mac2_t = mac2_t0<43:12>;
			else mac2_t = mac2_t0<31:0>;
			// A2(t);
			set_MAC2(mac2_t);

			// MAC3 = A3((((s64)CV3(cv) << 12) + (MX31(mx) * vx) + (MX32(mx) * vy) + (MX33(mx) * vz)) >> shift);
			sel mac3_t0<44>;
			mac3_t0 = (get_CV3(mvmva_cv).CV3 || 0x000) +
				44#smul_mac3_1.con(get_MX31(mvmva_mx).MX31, mvmva_vx).dout +
				44#smul_mac3_2.con(get_MX32(mvmva_mx).MX32, mvmva_vy).dout +
				44#smul_mac3_3.con(get_MX33(mvmva_mx).MX33, mvmva_vz).dout;
			sel mac3_t<32>;
			if(op<19>) mac3_t = mac3_t0<43:12>;
			else mac3_t = mac3_t0<31:0>;
			// A3(t);
			set_MAC3(mac3_t);

			generate MACtoIR.do(mvmva_lm);
			goto st_ir;
		}
		state st_ir par{
			// IR1 = limB1(MAC1, lm);
			// IR2 = limB2(MAC2, lm);
			// IR3 = limB3(MAC3, lm);
			goto st_init;
			finish;
		}
	}

	stage DPC_stg { // DPCS DPCT
		reg_wr dpc_st<2>;
		mul_s16 dpc_smul_mac1, dpc_smul_mac2, dpc_smul_mac3;
		gte_LIMIT lim_DPC;
		first_state st_init;
		par{
			instruct lim_DPC.set_FLAG set_FLAG(lim_DPC.FLAG);
			if(0b0){
				lim_DPC.limC1(0); lim_DPC.limC2(0); lim_DPC.limC3(0);
				lim_DPC.limD(0);
			}
		}
		state st_init par{
			reset_FLAG();
			dpc_st := 0;
			goto st_mac;
		}
		state st_mac par{
/*
			MAC1 = A1((
				(R << 16) + 
				(IR0 * limB1(
						A1( (s64)RFC - (R << 4) ) << (12 - shift), 0
				) )
			) >> 12);
*/
			sel shift;
			shift = op<19> | DPC_stg.dpct;

			sel r<8>;
			if(DPC_stg.dpcs) r = R;
			else r = R0;
			sel rfc_t<32+12>;
			if(shift) rfc_t = 44#RFC - (0x00000000 || r || 0x0);
			else      rfc_t = (RFC - (0x00000 || r || 0x0)) || 0x000;
			sel mac1_t<48>;
			mac1_t = (r || 0x0000) +
				48#dpc_smul_mac1.con(IR0, lim_DPC.limB1(rfc_t<31:0>, 0b0).limB1_ret).dout;
		//	A1(t);
			set_MAC1(mac1_t<43:12>);

			// MAC2 = A2(((G << 16) + (IR0 * limB2(A2((s64)GFC - (G << 4)) << (12 - shift), 0))) >> 12);
			sel g<8>;
			if(DPC_stg.dpcs) g = G;
			else g = G0;
			sel gfc_t<32+12>;
			if(shift) gfc_t = 44#GFC - (0x00000000 || g || 0x0);
			else      gfc_t = (GFC - (0x00000 || g || 0x0)) || 0x000;
			sel mac2_t<48>;
			if(DPC_stg.dpcs){
				mac2_t = (g || 0x0000) +
					48#dpc_smul_mac2.con(IR0, lim_DPC.limB2(gfc_t<31:0>, 0b0).limB2_ret).dout;
			}
			else{ // DPCT
				mac2_t = (g || 0x0000) +
					48#dpc_smul_mac2.con(IR0, lim_DPC.limB1(gfc_t<31:0>, 0b0).limB1_ret).dout;
			}
		//	A2(t);
			set_MAC2(mac2_t<43:12>);

			// MAC3 = A3(((B << 16) + (IR0 * limB3(A3((s64)BFC - (B << 4)) << (12 - shift), 0))) >> 12);
			sel b<8>;
			if(DPC_stg.dpcs) b = B;
			else b = B0;
			sel bfc_t<32+12>;
			if(shift) bfc_t = 44#BFC - (0x00000000 || b || 0x0);
			else      bfc_t = (BFC - (0x00000 || b || 0x0)) || 0x000;
			sel mac3_t<48>;
			if(DPC_stg.dpcs){
				mac3_t = (b || 0x0000) +
					48#dpc_smul_mac3.con(IR0, lim_DPC.limB3(bfc_t<31:0>, 0b0).limB3_ret).dout;
			}
			else{ // DPCT
				mac3_t = (b || 0x0000) +
					48#dpc_smul_mac3.con(IR0, lim_DPC.limB1(bfc_t<31:0>, 0b0).limB1_ret).dout;
			}
		//	A3(t);
			set_MAC3(mac3_t<43:12>);

			generate MACtoCODE2.do();
			if(DPC_stg.dpcs) generate MACtoIR.do(0b0);
			if(DPC_stg.dpct & (dpc_st==2)) generate MACtoIR.do(0b0);
			goto st_rgbir;
		}
		state st_rgbir par{
			// RGB0 = RGB1;
			// RGB1 = RGB2;
			// CODE2 = CODE;
			// R2 = limC1(MAC1 >> 4);
			// G2 = limC2(MAC2 >> 4);
			// B2 = limC3(MAC3 >> 4);

			// IR1 = limB1(MAC1, 0);
			// IR2 = limB2(MAC2, 0);
			// IR3 = limB3(MAC3, 0);

			if(DPC_stg.dpcs){
				goto st_init;
				finish;
			}
			else any{ // DPCT
				dpc_st==0 : goto st_mac;
				dpc_st==1 : goto st_mac;
				else : par{
					goto st_init;
					finish;
				}
			}
			dpc_st++;
		}
	}

	stage INTPL_stg { // 8 clk
		sel intpl_lm;
		mul_s16 intpl_smul_mac1, intpl_smul_mac2, intpl_smul_mac3;
		gte_LIMIT lim_INTPL;
		first_state st_init;

		par{
			// int lm = GTE_LM(op);
			intpl_lm = op<10>;

			instruct lim_INTPL.set_FLAG set_FLAG(lim_INTPL.FLAG);
			if(0b0){
				lim_INTPL.limC1(0); lim_INTPL.limC2(0); lim_INTPL.limC3(0);
				lim_INTPL.limD(0);
			}
		}

		state st_init par{
			reset_FLAG();
			goto st_mac;
		}
		state st_mac par{
/*
			MAC1 = A1(
				(
					(IR1 << 12) +
					(IR0 * limB1( ((s64)RFC - IR1), 0) )
				) >> shift
			);
*/
			sel mac1_t0<32>;
			mac1_t0 =
				32#(IR1 || 0x000) + 
				intpl_smul_mac1.con(IR0, lim_INTPL.limB1((RFC - 32#IR1), 0b0).limB1_ret).dout;
			sel mac1_t<32>;
			if(op<19>) mac1_t = 32#mac1_t0<31:12>;
			else mac1_t = mac1_t0;
		//	A1(t);
			set_MAC1(mac1_t);

			sel mac2_t0<32>;
			mac2_t0 =
				32#(IR2 || 0x000) + 
				intpl_smul_mac2.con(IR0, lim_INTPL.limB2((GFC - 32#IR2), 0b0).limB2_ret).dout;
			sel mac2_t<32>;
			if(op<19>) mac2_t = 32#mac2_t0<31:12>;
			else mac2_t = mac2_t0;
		//	A2(t);
			set_MAC2(mac2_t);

			sel mac3_t0<32>;
			mac3_t0 =
				32#(IR3 || 0x000) + 
				intpl_smul_mac3.con(IR0, lim_INTPL.limB3((BFC - 32#IR3), 0b0).limB3_ret).dout;
			sel mac3_t<32>;
			if(op<19>) mac3_t = 32#mac3_t0<31:12>;
			else mac3_t = mac3_t0;
		//	A3(t);
			set_MAC3(mac3_t);

			generate MACtoIR.do(intpl_lm);
			generate MACtoCODE2.do();
			goto st_irrgb;
		}
		state st_irrgb par{
			// IR1 = limB1(MAC1, lm);
			// IR2 = limB2(MAC2, lm);
			// IR3 = limB3(MAC3, lm);

			// RGB0 = RGB1;
			// RGB1 = RGB2;
			// CODE2 = CODE;
			// R2 = limC1(MAC1 >> 4);
			// G2 = limC2(MAC2 >> 4);
			// B2 = limC3(MAC3 >> 4);
			goto st_init;
			finish;
		}
	}

	stage SQR_stg {
		sel sqr_shift<5>, sqr_lm;
		mul_s16 sqr_smul_mac1, sqr_smul_mac2, sqr_smul_mac3;
		first_state st_init;

		par{
			// int shift = 12 * GTE_SF(op);
			sqr_shift = 0b01100 & 5#op<19>;
			// int lm = GTE_LM(op);
			sqr_lm = op<10>;
		}

		state st_init par{
			reset_FLAG();
			goto st_mac1;
		}
		state st_mac1 par{
			// MAC1 = A1((IR1 * IR1) >> shift);
			sqr_smul_mac1.con(IR1, IR1);
			sel mac1_t<32>;
			if(op<19>) mac1_t = 32#sqr_smul_mac1.dout<31:12>;
			else mac1_t = sqr_smul_mac1.dout;
		//	A1(t);
			set_MAC1(mac1_t);

			// MAC2 = A2((IR2 * IR2) >> shift);
			sqr_smul_mac2.con(IR2, IR2);
			sel mac2_t<32>;
			if(op<19>) mac2_t = 32#sqr_smul_mac2.dout<31:12>;
			else mac2_t = sqr_smul_mac2.dout;
		//	A2(t);
			set_MAC2(mac2_t);

			// MAC3 = A3((IR3 * IR3) >> shift);
			sqr_smul_mac3.con(IR3, IR3);
			sel mac3_t<32>;
			if(op<19>) mac3_t = 32#sqr_smul_mac3.dout<31:12>;
			else mac3_t = sqr_smul_mac3.dout;
		//	A3(t);
			set_MAC3(mac3_t);

			generate MACtoIR.do(sqr_lm);
			goto st_ir;
		}
		state st_ir par{
			// IR1 = limB1(MAC1, lm);
			// IR2 = limB2(MAC2, lm);
			// IR3 = limB3(MAC3, lm);
			goto st_init;
			finish;
		}
	}

	stage NC_stg { // NCS NCT
		reg_wr nc_st<2>, nc_v<5>, nc_vx<16>, nc_vy<16>, nc_vz<16>;
		first_state st_init;

		state st_init par{
			reset_FLAG();
			nc_v := 0;
			nc_st := 0;
			goto st_vset;
		}
		state st_vset par{
			nc_vx := get_VX(nc_v).VX;
			nc_vy := get_VY(nc_v).VY;
			nc_vz := get_VZ(nc_v).VZ;
			goto st_mac1_1;
		}

		state st_mac1_1 par{
			// MAC1 = A1((((s64)L11 * VX0) + (L12 * VY0) + (L13 * VZ0)) >> 12);
			sel mac1_t<32>;
			mac1_t = 32#(
				smul_mac1_1.con(L11, nc_vx).dout +
				smul_mac1_2.con(L12, nc_vy).dout +
				smul_mac1_3.con(L13, nc_vz).dout
				)<31:12>;
		//	A1(t);
			set_MAC1(mac1_t);

			// 	MAC2 = A2((((s64)L21 * VX0) + (L22 * VY0) + (L23 * VZ0)) >> 12);
			sel mac2_t<32>;
			mac2_t = 32#(
				smul_mac2_1.con(L21, nc_vx).dout +
				smul_mac2_2.con(L22, nc_vy).dout +
				smul_mac2_3.con(L23, nc_vz).dout
				)<31:12>;
		//	A2(t);
			set_MAC2(mac2_t);

			// MAC3 = A3((((s64)L31 * VX0) + (L32 * VY0) + (L33 * VZ0)) >> 12);
			sel mac3_t<32>;
			mac3_t = 32#(
				smul_mac3_1.con(L31, nc_vx).dout +
				smul_mac3_2.con(L32, nc_vy).dout +
				smul_mac3_3.con(L33, nc_vz).dout
				)<31:12>;
		//	A3(t);
			set_MAC3(mac3_t);

			generate MACtoIR.do(0b1);
			goto st_ir;
		}

		state st_mac1_2 par{
			// MAC1 = A1((((s64)RBK << 12) + (LR1 * IR1) + (LR2 * IR2) + (LR3 * IR3)) >> 12);
			sel mac1_t<32>;
			mac1_t = (
				(RBK || 0x000) +
				44#smul_mac1_1.con(LR1, IR1).dout +
				44#smul_mac1_2.con(LR2, IR2).dout +
				44#smul_mac1_3.con(LR3, IR3).dout
				)<43:12>;
		//	A1(t);
			set_MAC1(mac1_t);

			// MAC2 = A2((((s64)GBK << 12) + (LG1 * IR1) + (LG2 * IR2) + (LG3 * IR3)) >> 12);
			sel mac2_t<32>;
			mac2_t = (
				(GBK || 0x000) +
				44#smul_mac2_1.con(LG1, IR1).dout +
				44#smul_mac2_2.con(LG2, IR2).dout +
				44#smul_mac2_3.con(LG3, IR3).dout
				)<43:12>;
		//	A2(t);
			set_MAC2(mac2_t);

			// MAC3 = A3((((s64)BBK << 12) + (LB1 * IR1) + (LB2 * IR2) + (LB3 * IR3)) >> 12);
			sel mac3_t<32>;
			mac3_t = (
				(BBK || 0x000) +
				44#smul_mac3_1.con(LB1, IR1).dout +
				44#smul_mac3_2.con(LB2, IR2).dout +
				44#smul_mac3_3.con(LB3, IR3).dout
				)<43:12>;
		//	A3(t);
			set_MAC3(mac3_t);

			generate MACtoCODE2.do();
			goto st_rgb;
		}

		state st_rgb par{
			// RGB0 = RGB1;
			// RGB1 = RGB2;
			// CODE2 = CODE;
			// R2 = limC1(MAC1 >> 4);
			// G2 = limC2(MAC2 >> 4);
			// B2 = limC3(MAC3 >> 4);

			if(NC_stg.ncs | (nc_v==2)){
				generate MACtoIR.do(0b1);
				goto st_ir;
			}
			else{
				nc_st := 0;
				goto st_vset;
			}
			nc_v++;
		}

		state st_ir par{
			// IR1 = limB1(MAC1, 1);
			// IR2 = limB2(MAC2, 1);
			// IR3 = limB3(MAC3, 1);

			any{
				nc_st==0 : goto st_mac1_2;
				nc_st==1 : par{
					goto st_init;
					finish;
				}
			}
			nc_st++;
		}
	}

	stage NCD_stg { // NCDS NCDT
		reg_wr ncd_st<2>, ncd_v<5>, ncd_vx<16>, ncd_vy<16>, ncd_vz<16>;
		mul_s16 ncd_smul1_3, ncd_smul2_3, ncd_smul3_3;
		reg_wr ncd_mul_lim_reg<16>;
		gte_LIMIT lim_NCD;
		first_state st_init;

		par{
			instruct lim_NCD.set_FLAG set_FLAG(lim_NCD.FLAG);
			if(0b0){
				lim_NCD.limC1(0); lim_NCD.limC2(0); lim_NCD.limC3(0);
				lim_NCD.limD(0);
			}
		}

		state st_init par{
			reset_FLAG();
			ncd_v := 0;
			ncd_st := 0;
			goto st_vset;
		}
		state st_vset par{
			ncd_vx := get_VX(ncd_v).VX;
			ncd_vy := get_VY(ncd_v).VY;
			ncd_vz := get_VZ(ncd_v).VZ;
			goto st_mac1_1;
		}

		state st_mac1_1 par{
			// MAC1 = A1((((s64)L11 * VX0) + (L12 * VY0) + (L13 * VZ0)) >> 12);
			sel mac1_t<32>;
			mac1_t = 32#(
				smul_mac1_1.con(L11, ncd_vx).dout +
				smul_mac1_2.con(L12, ncd_vy).dout +
				smul_mac1_3.con(L13, ncd_vz).dout
				)<31:12>;
		//	A1(t);
			set_MAC1(mac1_t);

			// 	MAC2 = A2((((s64)L21 * VX0) + (L22 * VY0) + (L23 * VZ0)) >> 12);
			sel mac2_t<32>;
			mac2_t = 32#(
				smul_mac2_1.con(L21, ncd_vx).dout +
				smul_mac2_2.con(L22, ncd_vy).dout +
				smul_mac2_3.con(L23, ncd_vz).dout
				)<31:12>;
		//	A2(t);
			set_MAC2(mac2_t);

			// MAC3 = A3((((s64)L31 * VX0) + (L32 * VY0) + (L33 * VZ0)) >> 12);
			sel mac3_t<32>;
			mac3_t = 32#(
				smul_mac3_1.con(L31, ncd_vx).dout +
				smul_mac3_2.con(L32, ncd_vy).dout +
				smul_mac3_3.con(L33, ncd_vz).dout
				)<31:12>;
		//	A3(t);
			set_MAC3(mac3_t);

			generate MACtoIR.do(0b1);
			goto st_ir;
		}

		state st_mac1_2 par{
			// MAC1 = A1((((s64)RBK << 12) + (LR1 * IR1) + (LR2 * IR2) + (LR3 * IR3)) >> 12);
			sel mac1_t<32>;
			mac1_t = (
				(RBK || 0x000) +
				44#smul_mac1_1.con(LR1, IR1).dout +
				44#smul_mac1_2.con(LR2, IR2).dout +
				44#smul_mac1_3.con(LR3, IR3).dout
				)<43:12>;
		//	A1(t);
			set_MAC1(mac1_t);

			// MAC2 = A2((((s64)GBK << 12) + (LG1 * IR1) + (LG2 * IR2) + (LG3 * IR3)) >> 12);
			sel mac2_t<32>;
			mac2_t = (
				(GBK || 0x000) +
				44#smul_mac2_1.con(LG1, IR1).dout +
				44#smul_mac2_2.con(LG2, IR2).dout +
				44#smul_mac2_3.con(LG3, IR3).dout
				)<43:12>;
		//	A2(t);
			set_MAC2(mac2_t);

			// MAC3 = A3((((s64)BBK << 12) + (LB1 * IR1) + (LB2 * IR2) + (LB3 * IR3)) >> 12);
			sel mac3_t<32>;
			mac3_t = (
				(BBK || 0x000) +
				44#smul_mac3_1.con(LB1, IR1).dout +
				44#smul_mac3_2.con(LB2, IR2).dout +
				44#smul_mac3_3.con(LB3, IR3).dout
				)<43:12>;
		//	A3(t);
			set_MAC3(mac3_t);

			generate MACtoIR.do(0b1);
			goto st_ir;
		}

		state st_mac_3 par{
		//	ncd_mul_reg := ncd_smul3_3.con(0x00||R, IR1).dout;
			ncd_mul_lim_reg := lim_NCD.limB1(RFC - 32#ncd_smul3_3.con(0x00||R, IR1).dout<31:8>, 0b0).limB1_ret;
			goto st_mac1_3;
		}
		state st_mac1_3 par{
/*
			MAC1 = A1(
				(
					(((s64)R << 4) * IR1) +
					(IR0 * limB1(
						RFC - ((R * IR1) >> 8), 0
					))
				) >> 12
			);
*/
			sel t<32>;
			t = 32#(
				ncd_smul1_3.con(0x0||R||0x0, IR1).dout +
				ncd_smul2_3.con(IR0, ncd_mul_lim_reg).dout
				)<31:12>;
		//	A1(t);
			set_MAC1(t);

		//	ncd_mul_reg := ncd_smul3_3.con(0x00||G, IR2).dout;
			ncd_mul_lim_reg := lim_NCD.limB2(GFC - 32#ncd_smul3_3.con(0x00||G, IR2).dout<31:8>, 0b0).limB2_ret;
			goto st_mac2_3;
		}
		state st_mac2_3 par{
			// MAC2 = A2(((((s64)G << 4) * IR2) + (IR0 * limB2(GFC - ((G * IR2) >> 8), 0))) >> 12);
			sel t<32>;
			t = 32#(
				ncd_smul1_3.con(0x0||G||0x0, IR2).dout +
				ncd_smul2_3.con(IR0, ncd_mul_lim_reg).dout
				)<31:12>;
		//	A2(t);
			set_MAC2(t<31:0>);

		//	ncd_mul_reg := ncd_smul3_3.con(0x00||B, IR3).dout;
			ncd_mul_lim_reg := lim_NCD.limB3(BFC - 32#ncd_smul3_3.con(0x00||B, IR3).dout<31:8>, 0b0).limB3_ret;
			goto st_mac3_3;
		}
		state st_mac3_3 par{
			// MAC3 = A3(((((s64)B << 4) * IR3) + (IR0 * limB3(BFC - ((B * IR3) >> 8), 0))) >> 12);
			sel t<32>;
			t = 32#(
				ncd_smul1_3.con(0x0||B||0x0, IR3).dout +
				ncd_smul2_3.con(IR0, ncd_mul_lim_reg).dout
				)<31:12>;
		//	A3(t);
			set_MAC3(t);

			generate MACtoCODE2.do();
			goto st_rgb;
		}
		state st_rgb par{
			// RGB0 = RGB1;
			// RGB1 = RGB2;
			// CODE2 = CODE;
			// R2 = limC1(MAC1 >> 4);
			// G2 = limC2(MAC2 >> 4);
			// B2 = limC3(MAC3 >> 4);

			if(NCD_stg.ncds | (ncd_v==2)){
				generate MACtoIR.do(0b1);
				goto st_ir;
			}
			else{
				ncd_st := 0;
				goto st_vset;
			}
			ncd_v++;
		}

		state st_ir par{
			// IR1 = limB1(MAC1, 1);
			// IR2 = limB2(MAC2, 1);
			// IR3 = limB3(MAC3, 1);

			any{
				ncd_st==0 : goto st_mac1_2;
				ncd_st==1 : goto st_mac_3;
				ncd_st==2 : par{
					goto st_init;
					finish;
				}
			}
			ncd_st++;
		}
	}

	stage NCC_stg { // NCCS NCCT
		reg_wr ncc_st<2>, ncc_v<5>, ncc_vx<16>, ncc_vy<16>, ncc_vz<16>;
		first_state st_init;

		state st_init par{
			reset_FLAG();
			ncc_v := 0;
			ncc_st := 0;
			goto st_vset;
		}

		state st_vset par{
			ncc_vx := get_VX(ncc_v).VX;
			ncc_vy := get_VY(ncc_v).VY;
			ncc_vz := get_VZ(ncc_v).VZ;
			goto st_mac1_1;
		}

		state st_mac1_1 par{
			// MAC1 = A1((((s64)L11 * VX0) + (L12 * VY0) + (L13 * VZ0)) >> 12);
			sel mac1_t<32>;
			mac1_t = 32#(
				smul_mac1_1.con(L11, ncc_vx).dout +
				smul_mac1_2.con(L12, ncc_vy).dout +
				smul_mac1_3.con(L13, ncc_vz).dout
				)<31:12>;
			// A1(t);
			set_MAC1(mac1_t);

			// MAC2 = A2((((s64)L21 * VX0) + (L22 * VY0) + (L23 * VZ0)) >> 12);
			sel mac2_t<32>;
			mac2_t = 32#(
				smul_mac2_1.con(L21, ncc_vx).dout +
				smul_mac2_2.con(L22, ncc_vy).dout +
				smul_mac2_3.con(L23, ncc_vz).dout
				)<31:12>;
			// A2(t);
			set_MAC2(mac2_t);

			// MAC3 = A3((((s64)L31 * VX0) + (L32 * VY0) + (L33 * VZ0)) >> 12);
			sel mac3_t<32>;
			mac3_t = 32#(
				smul_mac3_1.con(L31, ncc_vx).dout +
				smul_mac3_2.con(L32, ncc_vy).dout +
				smul_mac3_3.con(L33, ncc_vz).dout
				)<31:12>;
			// A3(t);
			set_MAC3(mac3_t);

			generate MACtoIR.do(0b1);
			goto st_ir;
		}

		state st_mac1_2 par{
			// MAC1 = A1((((s64)RBK << 12) + (LR1 * IR1) + (LR2 * IR2) + (LR3 * IR3)) >> 12);
			sel mac1_t<32>;
			mac1_t = (
				(RBK || 0x000) +
				44#smul_mac1_1.con(LR1, IR1).dout + 
				44#smul_mac1_2.con(LR2, IR2).dout + 
				44#smul_mac1_3.con(LR3, IR3).dout
				)<43:12>;
			// A1(t);
			set_MAC1(mac1_t);

			// MAC2 = A2((((s64)GBK << 12) + (LG1 * IR1) + (LG2 * IR2) + (LG3 * IR3)) >> 12);
			sel mac2_t<32>;
			mac2_t = (
				(GBK || 0x000) +
				44#smul_mac2_1.con(LG1, IR1).dout + 
				44#smul_mac2_2.con(LG2, IR2).dout + 
				44#smul_mac2_3.con(LG3, IR3).dout
				)<43:12>;
			// A2(t);
			set_MAC2(mac2_t);

			// MAC3 = A3((((s64)BBK << 12) + (LB1 * IR1) + (LB2 * IR2) + (LB3 * IR3)) >> 12);
			sel mac3_t<32>;
			mac3_t = (
				(BBK || 0x000) +
				44#smul_mac3_1.con(LB1, IR1).dout + 
				44#smul_mac3_2.con(LB2, IR2).dout + 
				44#smul_mac3_3.con(LB3, IR3).dout
				)<43:12>;
			// A3(t);
			set_MAC3(mac3_t);

			generate MACtoIR.do(0b1);
			goto st_ir;
		}

		state st_mac_3 par{
			// MAC1 = A1(((s64)R * IR1) >> 8);
			sel mac1_t<32>;
			mac1_t = 32#smul_mac1.con(0x00||R, IR1).dout<31:8>;
			//A1(t1);
			set_MAC1(mac1_t);

			// MAC2 = A2(((s64)G * IR2) >> 8);
			sel mac2_t<32>;
			mac2_t = 32#smul_mac2.con(0x00||G, IR2).dout<31:8>;
			//A2(t2);
			set_MAC2(mac2_t);

			// MAC3 = A3(((s64)B * IR3) >> 8);
			sel mac3_t<32>;
			mac3_t = 32#smul_mac3.con(0x00||B, IR3).dout<31:8>;
			//A3(t3);
			set_MAC3(mac3_t);

			generate MACtoCODE2.do();
			goto st_rgb;
		}
		state st_rgb par{
			// RGB0 = RGB1;
			// RGB1 = RGB2;
			// CODE2 = CODE;
			// R2 = limC1(MAC1 >> 4);
			// G2 = limC2(MAC2 >> 4);
			// B2 = limC3(MAC3 >> 4);

			if(NCC_stg.nccs | (ncc_v==2)){
				generate MACtoIR.do(0b1);
				goto st_ir;
			}
			else{
				ncc_st := 0;
				goto st_vset;
			}
			ncc_v++;
		}
/*
v st
0 0
0 1
1 0
1 1
2 0
2 1
3 2
*/
		state st_ir par{
			// IR1 = limB1(MAC1, 1);
			// IR2 = limB2(MAC2, 1);
			// IR3 = limB3(MAC3, 1);

			any{
				ncc_st==0 : goto st_mac1_2;
				ncc_st==1 : goto st_mac_3;
				ncc_st==2 : par{
					goto st_init;
					finish;
				}
			}
			ncc_st++;
		}
	}

	stage CC_stg {
		reg_wr cc_st<2>;
		first_state st_init;
		state st_init par{
			reset_FLAG();
			cc_st := 0;
			goto st_mac_1;
		}
		state st_mac_1 par{
			// MAC1 = A1(
			//	(
			//		((s64)RBK << 12) + (LR1 * IR1) + (LR2 * IR2) + (LR3 * IR3)
			//	) >> 12
			// );
			sel mac1_t<32>;
			mac1_t = (
				(RBK || 0x000) +
				44#smul_mac1_1.con(LR1, IR1).dout + 
				44#smul_mac1_2.con(LR2, IR2).dout + 
				44#smul_mac1_3.con(LR3, IR3).dout
				)<43:12>;
			// A1(t);
			set_MAC1(mac1_t);

			sel mac2_t<32>;
			mac2_t = (
				(GBK || 0x000) +
				44#smul_mac2_1.con(LG1, IR1).dout + 
				44#smul_mac2_2.con(LG2, IR2).dout + 
				44#smul_mac2_3.con(LG3, IR3).dout
				)<43:12>;
			// A2(t);
			set_MAC2(mac2_t);

			sel mac3_t<32>;
			mac3_t = (
				(BBK || 0x000) +
				44#smul_mac3_1.con(LB1, IR1).dout + 
				44#smul_mac3_2.con(LB2, IR2).dout + 
				44#smul_mac3_3.con(LB3, IR3).dout
				)<43:12>;
			// A3(t);
			set_MAC3(mac3_t);

			generate MACtoIR.do(0b1);
			goto st_ir;
		}
		state st_mac_2 par{
			// MAC1 = A1(((s64)R * IR1) >> 8);
			sel mac1_t<32>;
			mac1_t = 32#smul_mac1.con(0x00||R, IR1).dout<31:8>;
			//A1(t1);
			set_MAC1(mac1_t);

			// MAC2 = A2(((s64)G * IR2) >> 8);
			sel mac2_t<32>;
			mac2_t = 32#smul_mac2.con(0x00||G, IR2).dout<31:8>;
			//A2(t2);
			set_MAC2(mac2_t);

			// MAC3 = A3(((s64)B * IR3) >> 8);
			sel mac3_t<32>;
			mac3_t = 32#smul_mac3.con(0x00||B, IR3).dout<31:8>;
			//A3(t3);
			set_MAC3(mac3_t);

			generate MACtoIR.do(0b1);
			generate MACtoCODE2.do();
			goto st_ir;
		}
		state st_ir par{
			any{
				cc_st==0 : goto st_mac_2;
				cc_st==1 : par{
					goto st_init;
					finish;
				}
			}
			cc_st++;
		}
	}

	stage NCLIP_stg {
		mul_s16 nclip_smul0, nclip_smul1, nclip_smul2;
		first_state st_init;
		state st_init par{
			reset_FLAG();
			goto st_mac0;
		}
		state st_mac0 par{
/*
			MAC0 = F(
				(s64)SX0 * (SY1 - SY2) +
				SX1 * (SY2 - SY0) +
				SX2 * (SY0 - SY1)
			);
*/
			sel t<32>;
			t = 
				nclip_smul0.con(SX0, (SY1 - SY2)).dout +
				nclip_smul1.con(SX1, (SY2 - SY0)).dout +
				nclip_smul2.con(SX2, (SY0 - SY1)).dout;
		//	F(t);
			set_MAC0(t);
			goto st_init;
			finish;
		}
	}

	stage AVSZ3_stg {
		reg_wr sz3_add<16>;
		mul_s16 avsz3_smul;
		gte_LIMIT lim_AVSZ3;
		first_state st_init;

		par{
			instruct lim_AVSZ3.set_FLAG set_FLAG(lim_AVSZ3.FLAG);
			if(0b0){
				lim_AVSZ3.limB1(0,0); lim_AVSZ3.limB2(0,0); lim_AVSZ3.limB3(0,0);
				lim_AVSZ3.limC1(0); lim_AVSZ3.limC2(0); lim_AVSZ3.limC3(0);
			}
		}

		state st_init par{
			reset_FLAG();
			sz3_add := SZ1 + SZ2 + SZ3;
			goto st_mac0;
		}
		state st_mac0 par{
			sel t<32>;
			t = avsz3_smul.con(ZSF3, sz3_add).dout;
			set_MAC0(t);
			// OTZ = limD(t >> 12);
			set_OTZ(lim_AVSZ3.limD(32#t<31:12>).limD_ret);
			goto st_init;
			finish;
		}
	}

	stage AVSZ4_stg {
		reg_wr sz4_sum<18>;
		mul_s32 avsz4_smul;
		gte_LIMIT lim_AVSZ4;
		first_state st_init;

		par{
			instruct lim_AVSZ4.set_FLAG set_FLAG(lim_AVSZ4.FLAG);
			if(0b0){
				lim_AVSZ4.limB1(0,0); lim_AVSZ4.limB2(0,0); lim_AVSZ4.limB3(0,0);
				lim_AVSZ4.limC1(0); lim_AVSZ4.limC2(0); lim_AVSZ4.limC3(0);
			}
		}

		state st_init par{
			reset_FLAG();
			sz4_sum := (0b00||SZ0) + (0b00||SZ1) + (0b00||SZ2) + (0b00||SZ3); // [16][17][18][19]<16>
			goto st_mac0;
		}
		state st_mac0 par{
			sel t<64>;
			// s16 * u18 = s34
			t = avsz4_smul.con(32#ZSF4, 14#0b0||sz4_sum).dout; // signed c[30]<15:0>
			set_MAC0(t<31:0>); // [24]
			// OTZ = limD(t >> 12);
			set_OTZ(lim_AVSZ4.limD(32#t<31:12>).limD_ret); // [7]
			goto st_init;
			finish;
		}
	}

	stage OP_stg {
		sel op_lm;
		first_state st_init;

		par{
			// int shift = 12 * GTE_SF(op);
		//	op_shift = 0b01100 & 5#op<19>;
			// int lm = GTE_LM(op);
			op_lm = op<10>;
		}

		state st_init par{
			reset_FLAG();
			goto st_mac1;
		}
		state st_mac1 par{
			// MAC1 = A1(((s64)(R22 * IR3) - (R33 * IR2)) >> shift);
			sel mac1_t0<32>;
			mac1_t0 =
				smul_mac1_1.con(R22, IR3).dout -
				smul_mac1_2.con(R33, IR2).dout;
			sel mac1_t<32>;
			if(op<19>) mac1_t = 32#mac1_t0<31:12>;
			else mac1_t = mac1_t0;
			//A1(t);
			set_MAC1(mac1_t);

			// MAC2 = A2(((s64)(gteR33 * gteIR1) - (gteR11 * gteIR3)) >> shift);
			sel mac2_t0<32>;
			mac2_t0 =
				smul_mac2_1.con(R33, IR1).dout -
				smul_mac2_2.con(R11, IR3).dout;
			sel mac2_t<32>;
			if(op<19>) mac2_t = 32#mac2_t0<31:12>;
			else mac2_t = mac2_t0;
			//A2(t);
			set_MAC2(mac2_t);

			// MAC3 = A3(((s64)(gteR11 * gteIR2) - (gteR22 * gteIR1)) >> shift);
			sel mac3_t0<32>;
			mac3_t0 =
				smul_mac3_1.con(R11, IR2).dout -
				smul_mac3_2.con(R22, IR1).dout;
			sel mac3_t<32>;
			if(op<19>) mac3_t = 32#mac3_t0<31:12>;
			else mac3_t = mac3_t0;
			//A3(t);
			set_MAC3(mac3_t);

			generate MACtoIR.do(op_lm);
			goto st_ir;
		}
		state st_ir par{
			// IR1 = limB1(MAC1, lm);
			// IR2 = limB2(MAC2, lm);
			// IR3 = limB3(MAC3, lm);

			goto st_init;
			finish;
		}
	}

	stage GPF_stg {
		sel gpf_lm;
		mul_s16 gpf_smul_mac1, gpf_smul_mac2, gpf_smul_mac3;
		first_state st_init;

		par{
			// int shift = 12 * GTE_SF(op);
		//	gpf_shift = 0b01100 & 5#op<19>;
			// int lm = GTE_LM(op);
			gpf_lm = op<10>;
		}

		state st_init par{
			reset_FLAG();
			goto st_mac1;
		}
		state st_mac1 par{
			// MAC1 = A1((s64)(IR0 * IR1)) >> shift;
			gpf_smul_mac1.con(IR0, IR1);
			sel mac1_t<32>;
			if(op<19>) mac1_t = 32#gpf_smul_mac1.dout<31:12>;
			else mac1_t = gpf_smul_mac1.dout;
		//	A1(t);
			set_MAC1(mac1_t);

			// MAC2 = A2((s64)(IR0 * IR2)) >> shift;
			gpf_smul_mac2.con(IR0, IR2);
			sel mac2_t<32>;
			if(op<19>) mac2_t = 32#gpf_smul_mac2.dout<31:12>;
			else mac2_t = gpf_smul_mac2.dout;
		//	A2(t);
			set_MAC2(mac2_t);

			// MAC3 = A3((s64)(IR0 * IR3)) >> shift;
			gpf_smul_mac3.con(IR0, IR3);
			sel mac3_t<32>;
			if(op<19>) mac3_t = 32#gpf_smul_mac3.dout<31:12>;
			else mac3_t = gpf_smul_mac3.dout;
		//	A3(t);
			set_MAC3(mac3_t);

			generate MACtoIR.do(gpf_lm);
			generate MACtoCODE2.do();
			goto st_irrgb;
		}
		state st_irrgb par{
			// IR1 = limB1(MAC1, lm);
			// IR2 = limB2(MAC2, lm);
			// IR3 = limB3(MAC3, lm);

			// RGB0 = RGB1;
			// RGB1 = RGB2;
			// CODE2 = CODE;
			// R2 = limC1(MAC1 >> 4);
			// G2 = limC2(MAC2 >> 4);
			// B2 = limC3(MAC3 >> 4);

			goto st_init;
			finish;
		}
	}

	stage GPL_stg {
		sel gpl_lm;
		mul_s16 gpl_smul_mac1, gpl_smul_mac2, gpl_smul_mac3;
		first_state st_init;

		par{
			// int shift = 12 * GTE_SF(op);
		//	gpl_shift = 0b01100 & 5#op<19>;
			// int lm = GTE_LM(op);
			gpl_lm = op<10>;
		}

		state st_init par{
			reset_FLAG();
			goto st_mac1;
		}
		state st_mac1 par{
/*
			MAC1 = A1(
				(((s64)MAC1 << shift) + (IR0 * IR1)) >> shift
			);
*/
			gpl_smul_mac1.con(IR0, IR1);
			sel mac1_t<44>;
			if(op<19>) mac1_t = 44#(MAC1||0x000 + 44#gpl_smul_mac1.dout)<31:12>;
			else mac1_t = 44#MAC1 + 44#gpl_smul_mac1.dout;
		//	A1(t);
			set_MAC1(mac1_t<31:0>);

			// MAC2 = A2((((s64)MAC2 << shift) + (IR0 * IR2)) >> shift);
			gpl_smul_mac2.con(IR0, IR2);
			sel mac2_t<44>;
			if(op<19>) mac2_t = 44#(MAC2||0x000 + 44#gpl_smul_mac2.dout)<31:12>;
			else mac2_t = 44#MAC2 + 44#gpl_smul_mac2.dout;
		//	A2(t);
			set_MAC2(mac2_t<31:0>);

			// MAC3 = A3((((s64)MAC3 << shift) + (IR0 * IR3)) >> shift);
			gpl_smul_mac3.con(IR0, IR3);
			sel mac3_t<44>;
			if(op<19>) mac3_t = 44#(MAC3||0x000 + 44#gpl_smul_mac3.dout)<31:12>;
			else mac3_t = 44#MAC3 + 44#gpl_smul_mac3.dout;
		//	A3(t);
			set_MAC3(mac3_t<31:0>);

			generate MACtoIR.do(gpl_lm);
			generate MACtoCODE2.do();
			goto st_irrgb;
		}
		state st_irrgb par{
			// IR1 = limB1(MAC1, lm);
			// IR2 = limB2(MAC2, lm);
			// IR3 = limB3(MAC3, lm);

			// RGB0 = RGB1;
			// RGB1 = RGB2;
			// CODE2 = CODE;
			// R2 = limC1(MAC1 >> 4);
			// G2 = limC2(MAC2 >> 4);
			// B2 = limC3(MAC3 >> 4);
			goto st_init;
			finish;
		}
	}

}
