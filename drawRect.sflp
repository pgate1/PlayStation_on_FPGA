/*
	GPU draw Rect
		by pgate1
*/

declare compare_s11 interface
{
	input a<11>, b<11>;
	instrin gt, lt, gte, lte;
	output result;
	instr_arg gt(a, b);
	instr_arg lt(a, b);
	instr_arg gte(a, b);
	instr_arg lte(a, b);
}

circuit drawRect
{
	input vx1<11>, vy1<11>;
	input vx4<11>, vy4<11>;
	input col<24>;
	input clut<16>, tpage<14>;
	input vu1<8>, vv1<8>;
	input vu4<8>, vv4<8>;
	input drawX<10>, drawY<10>, drawW<10>, drawH<10>;
	instrin con(vx1, vy1, vx4, vy4, col, clut, tpage, vu1, vv1, vu4, vv4, drawX, drawY, drawW, drawH);

	instrin sw_view_half_width, sw_view_half_height;

	instrin draw;
	output drawing;

	instrself x_add;

	reg x<11>, y<11>;
	compare_s11 cmp_w, cmp_h;

	reg u<8>, v<8>;

	input f_texture;
	input f_texblend;
	input f_semitrans;

	// VIEW
	output view_x<10>, view_y<9>;
	instrout view_on(view_x, view_y);
	output out_R<8>, out_G<8>, out_B<8>;

	// VRAM
	output vram_adrs<19>;
	reg vram_adrs_reg<19>;
	instrself vram_read(vram_adrs);
	instrout vram_read_req;
	instrin vram_ack;
	input vram_read_data<16>;

	// TextureCache
	instrout tcache_read(tcache_adrs);
	output tcache_adrs<19>;
	input tcache_dout<16>, tcache_ack;

	reg_wr halt;

	stage_name draw_stg { task do(); }
	stage_name bilinear_vbase { task do(); }
	stage_name texdraw { task do(); }

	instruct draw generate draw_stg.do();
	drawing = draw_stg.do;

	reg_wr vram_read_wait;
	if(vram_read){
		vram_adrs_reg := vram_adrs;
		vram_read_req();
		vram_read_wait := 0b1;
	}
	else{
		vram_adrs = vram_adrs_reg;
	}
	if(vram_read_wait & ^vram_ack) vram_read_req();
	if(vram_ack){
		vram_read_wait := 0b0;
	}

	under640 = (vx1-0b01010000000)<10>; // x < 640

	sel clut_p<19>, tadjust_y<19>, tpage_col<2>;
	sel clut_x<10>, clut_y<9>;
	clut_x = clut<5:0> || 0b0000;
	clut_y = clut<14:6>;
	clut_p = clut_y || clut_x;

	sel tbase_x<10>, tbase_y<9>;
	tbase_x = tpage<3:0> || 0b000000;
	tbase_y = tpage<4> || 0b00000000;
	tadjust_y = tbase_y || tbase_x;
	tpage_col = tpage<8:7>;

	sel tr<8>, tg<8>, tb<8>;
	if(f_texture){
		out_R = tr;
		out_G = tg;
		out_B = tb;
	}
	else{
		out_R = col<7:0>;
		out_G = col<15:8>;
		out_B = col<23:16>;
	}

	instruct x_add par{
		if(under640 & sw_view_half_width){
			x += 2;
			u += 2;
		}
		else{
			x++;
			u++;
		}
	}

	stage draw_stg {
		first_state st1;
		par{
			if(0b0){
				cmp_w.lt(0,0); cmp_w.gte(0,0); cmp_w.lte(0,0);
				cmp_h.lt(0,0); cmp_h.gte(0,0); cmp_h.lte(0,0);
			}
		}
		state st1 par{
			if((vy1<10> & vy4<10>) | (vx1<10> & vx4<10>)){ // y < 0, x < 0
				finish;
			}
			else goto st3;
			y := vy1;
			v := vv1;
		}
		state st3 par{
			alt{
				y<10> // y < 0
				| ((y-(0b0||drawY))<10>==0b1) // y < drawY ドローライン未満
				: par{
					y++;
					v++;
				}
				((y-vy4)<10>==0b0) // y >= ey
				| cmp_h.gt(y, 0b0||drawH).result : par{ // y > drawH ドローライン超え
					goto st1;
					finish;
				}
				else : par{ // y < ey 描画ライン
					goto st4;
				}
			}
			x := vx1;
			u := vu1;
		}
		state st4 if(^vram_read_wait & ^texdraw.do){
			if(
			//	((vx4-x)<10>==0b1) // x > ex
				((x-vx4)<10>==0b0) // x >= ex
				| cmp_w.gt(x, 0b0||drawW).result // x > drawW ドロードット超え
			){
				if(sw_view_half_height){
					y += 2;
					v += 2;
				}
				else{
					y++;
					v++;
				}
				goto st3;
			}
			else{ // x < ex
				if(
				//	(y<10>==0b0)          // y >= 0
				//	& (y-0b00111100000)<10> // y < 480
					(x<10>==0b0)          // x >= 0
				//	& (x-0b01010000000)<10> // x < 640
					& ((x-(0b0||drawX))<10>==0b0) // x >= drawX // ドロードット以上
				){
					any{
						f_texture : par{
							sel vadrs<19>;
							any{
								tpage_col==0 : vadrs = (0b0 || v || 10#0b0) + tadjust_y + (13#0b0 || u<7:2>);
								tpage_col==1 : vadrs = (0b0 || v || 10#0b0) + tadjust_y + (12#0b0 || u<7:1>);
								else : par{ // tpage_col==2,3
									vadrs = (0b0 || v || 10#0b0) + tadjust_y + (11#0b0 || u);
								}
							}
							tcache_read(vadrs);
							generate texdraw.do();
						}
						else : par{
							view_on(x<9:0>, y<8:0>);
							x_add();
						}
					}
				}
				else{
					x_add();
				}
			}

		}
	}

	stage texdraw {
		reg clut_adrs_reg<19> = -1, clut_data<16>;
		instrself clut_data_valid;
		if(tcache_ack){
			reg_wr tex_st;
			if(tex_st==0b0){
				sel clut_adrs<19>;
				any{
					tpage_col==0 : par{
						sel tci<4>;
						tci = (tcache_dout >> (u<1:0> || 0b00))<3:0>;
						clut_adrs = clut_p + (15#0b0 || tci);
					}
					tpage_col==1 : par{
						sel tci<8>;
						tci = (tcache_dout >> (u<0> || 0b000))<7:0>;
						clut_adrs = clut_p + (11#0b0 || tci);
					}
					tpage_col<1>==0b0 : par{
						if(clut_adrs!=clut_adrs_reg){
							vram_read(clut_adrs);
							clut_adrs_reg := clut_adrs;
							tex_st := 0b1;
						}
						else clut_data_valid();
					}
				}
			}

			if(tpage_col<1> | (tex_st & vram_ack) | clut_data_valid){
				sel tex_data<16>;
				if(tpage_col<1>) tex_data = tcache_dout;
				else{
					if(clut_data_valid) tex_data = clut_data;
					else{
						tex_data = vram_read_data;
						clut_data := vram_read_data;
					}
				}
				if((tex_data<14:0>!=0) | (tex_data==0x8000)){
					view_on(x<9:0>, y<8:0>);
					tr = tex_data< 4: 0> || 0b000;
					tg = tex_data< 9: 5> || 0b000;
					tb = tex_data<14:10> || 0b000;
				}

				x_add();

				tex_st := 0b0;
				finish;
			}
		}
	}

}
